{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLAlchemy bind manager","text":"<p>This package provides an easy way to configure and use SQLAlchemy without depending on frameworks.</p> <p>It is composed by two main components:</p> <ul> <li>A manager class for SQLAlchemy engine and session configuration</li> <li>A repository/unit-of-work pattern implementation for model retrieval and persistence</li> </ul>"},{"location":"#why-another-sqlalchemy-helper-package","title":"Why another SQLAlchemy helper package?","text":"<p>There are some existing plugins that help the creation of the standard SQLAlchemy boilerplate code for engine, session and base declarative model, but they mainly aim to integrate with existing frameworks.</p> <p>In order to create a maintainable application it is important to use a framework, but to not be limited by it. It might be desirable to switch to more modern technologies and binding the storage layer with the framework would bring a high degree of complexity.</p> <p>Also implementing a highly decoupled application would use abstractions between the application  logic and the storage, therefore this package provides a base implementation of a storage abstraction layer (Repository).</p> <p>The scope of this package is to:</p> <ul> <li>Be able to setup a basic application with a few lines of code</li> <li>Avoid common pitfalls found in other plugins for session lifecycle</li> <li>Allow to build a decoupled application without being bound to HTTP frameworks</li> </ul>"},{"location":"#components-maturity","title":"Components maturity","text":"<p>The components have a high test coverage, and it should not be necessary to change the interfaces, however this might be necessary until version <code>1.0</code> is released.</p> <ul> <li> SQLAlchemy manager: Implementation is mostly finalised, needs testing in production.</li> <li> Repository: Implementation is mostly finalised, needs testing in production.</li> <li> Unit of work: The implementation is working but limited to repositories using the same engine. Distributed transactions across different engines are not yet supported.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install sqlalchemy-bind-manager\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy import String\n\nconfig = SQLAlchemyConfig(\n    engine_url=\"sqlite:///./sqlite.db\",\n    engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n    session_options=dict(expire_on_commit=False),\n)\n\n# Initialise the bind manager\nsa_manager = SQLAlchemyBindManager(config)\n\n# Declare a model\nclass MyModel(sa_manager.get_bind().declarative_base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n\n# Initialise the tables in the db\nbind = sa_manager.get_bind()\nbind.registry_mapper.metadata.create_all(bind.engine)\n\n# Create and save a model\no = MyModel()\no.name = \"John\"\nwith sa_manager.get_session() as session:\n    session.add(o)\n    session.commit()\n</code></pre> Long lived sessions and multithreading <p>It's not recommended to create long-lived sessions like:</p> <pre><code>session = sa_manager.get_session()\n</code></pre> <p>This can create unexpected because of global variables and multi-threading. More details can be found in the session page</p>"},{"location":"lifecycle/","title":"Components life cycle","text":""},{"location":"lifecycle/#when-should-you-create-each-component","title":"When should you create each component?","text":""},{"location":"lifecycle/#bind-manager","title":"Bind manager","text":"<p>The <code>SQLAlchemyBindManager</code> object holds all the SQLAlchemy Engines, which are supposed to be global objects, therefore it should be created on application startup and be globally accessible.</p> <p>From SQLAlchemy documentation:</p> <p>The Engine is intended to normally be a permanent fixture established up-front and maintained throughout the lifespan of an application.</p>"},{"location":"lifecycle/#repositories","title":"Repositories","text":"<p>SQLAlchemy documentation recommends we create <code>Session</code> object at the beginning of a logical operation where database access is potentially anticipated.</p> <p>The repository keeps a <code>Session</code> object scoped to its lifecycle to avoid unnecessary queries, and executes a transaction for each operation to maintain isolation. This means you can create a repository object almost whenever you want, as long as you don't run parallel operations.</p> <p>The repository is safe in multithreaded applications and in concurrent asyncio tasks, this means that potentially you can save it in a global variable, and it will have a different <code>Session</code> in each thread or asyncio task.</p> <p>Even if the repository can be used with concurrency or parallelism, remember SQLAlchemy models belong to a single <code>Session</code>, so sharing the same models in multiple threads or asyncio tasks will cause problems.</p> <p>What you can do is:</p> <ul> <li>Save the repositories in global variables and start a thread / asyncio task to handle   a scoped request (e.g. one thread per HTTP request)</li> </ul> <p>What you should not do is:</p> <ul> <li>Get a list of models</li> <li>Save the models using <code>save()</code> in parallel threads / tasks (each task will have a different session)</li> </ul> <p>Remember: Concurrent writes to the db can cause undesired scenarios like locks and deadlocks!</p> <p>The recommendation is to try to use a single repository instance, where possible.</p> <p>For example a strategy similar to this would be optimal, if possible:</p> <ul> <li>Create repositories</li> <li>Retrieve all the models you need</li> <li>Do the changes you need, as per business logic, eventually using multiple threads / tasks</li> <li>Save all the changed models as needed</li> </ul>"},{"location":"lifecycle/#unit-of-work","title":"Unit of work","text":"<p>The Unit of Work session management follows the same exact rules as the repository, therefore you should approach the creation af a <code>UnitOfWork</code> object in the same way.</p>"},{"location":"API-Reference/","title":"Index","text":""},{"location":"API-Reference/_bind_manager/","title":"bind manager","text":""},{"location":"API-Reference/_bind_manager/#sqlalchemy_bind_manager._bind_manager.SQLAlchemyBindManager","title":"<code>SQLAlchemyBindManager</code>","text":"Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>class SQLAlchemyBindManager:\n    __binds: MutableMapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]\n\n    def __init__(\n        self,\n        config: _SQLAlchemyConfig,\n    ) -&gt; None:\n        self.__binds = {}\n        if isinstance(config, Mapping):\n            for name, conf in config.items():\n                self.__init_bind(name, conf)\n        else:\n            self.__init_bind(DEFAULT_BIND_NAME, config)\n\n    def __init_bind(\n        self, name: str, config: Union[SQLAlchemyConfig, SQLAlchemyAsyncConfig]\n    ):\n        if not any(\n            [\n                isinstance(config, SQLAlchemyConfig),\n                isinstance(config, SQLAlchemyAsyncConfig),\n            ]\n        ):\n            raise InvalidConfigError(\n                f\"Config for bind `{name}` is not a SQLAlchemyConfig\"\n                f\" or SQLAlchemyAsyncConfig object\"\n            )\n\n        engine_options: dict = config.engine_options or {}\n        engine_options.setdefault(\"echo\", False)\n        engine_options.setdefault(\"future\", True)\n\n        session_options: dict = config.session_options or {}\n        session_options.setdefault(\"expire_on_commit\", False)\n        session_options.setdefault(\"autobegin\", False)\n\n        if isinstance(config, SQLAlchemyAsyncConfig):\n            self.__binds[name] = self.__build_async_bind(\n                engine_url=config.engine_url,\n                engine_options=engine_options,\n                session_options=session_options,\n            )\n        else:\n            self.__binds[name] = self.__build_sync_bind(\n                engine_url=config.engine_url,\n                engine_options=engine_options,\n                session_options=session_options,\n            )\n\n    def __build_sync_bind(\n        self,\n        engine_url: str,\n        engine_options: dict,\n        session_options: dict,\n    ) -&gt; SQLAlchemyBind:\n        registry_mapper = registry()\n        engine = create_engine(engine_url, **engine_options)\n        return SQLAlchemyBind(\n            engine=engine,\n            registry_mapper=registry_mapper,\n            session_class=sessionmaker(\n                bind=engine,\n                class_=Session,\n                **session_options,\n            ),\n            declarative_base=registry_mapper.generate_base(),\n        )\n\n    def __build_async_bind(\n        self,\n        engine_url: str,\n        engine_options: dict,\n        session_options: dict,\n    ) -&gt; SQLAlchemyAsyncBind:\n        registry_mapper = registry()\n        engine = create_async_engine(engine_url, **engine_options)\n        return SQLAlchemyAsyncBind(\n            engine=engine,\n            registry_mapper=registry_mapper,\n            session_class=async_sessionmaker(\n                bind=engine,\n                **session_options,\n            ),\n            declarative_base=registry_mapper.generate_base(),\n        )\n\n    def get_binds(self) -&gt; Mapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]:\n        return self.__binds\n\n    def get_bind_mappers_metadata(self) -&gt; Mapping[str, MetaData]:\n        \"\"\"\n        Returns the mappers metadata in a format that can be used\n        in Alembic configuration\n\n        :returns: mappers metadata\n        :rtype: dict\n        \"\"\"\n        return {k: b.registry_mapper.metadata for k, b in self.__binds.items()}\n\n    def get_bind(\n        self, bind_name: str = DEFAULT_BIND_NAME\n    ) -&gt; Union[SQLAlchemyBind, SQLAlchemyAsyncBind]:\n        try:\n            return self.__binds[bind_name]\n        except KeyError:\n            raise NotInitializedBindError(\"Bind not initialized\")\n\n    def get_session(\n        self, bind_name: str = DEFAULT_BIND_NAME\n    ) -&gt; Union[Session, AsyncSession]:\n        return self.get_bind(bind_name).session_class()\n\n    def get_mapper(self, bind_name: str = DEFAULT_BIND_NAME) -&gt; registry:\n        return self.get_bind(bind_name).registry_mapper\n</code></pre>"},{"location":"API-Reference/_bind_manager/#sqlalchemy_bind_manager._bind_manager.SQLAlchemyBindManager.get_bind_mappers_metadata","title":"<code>get_bind_mappers_metadata()</code>","text":"<p>Returns the mappers metadata in a format that can be used in Alembic configuration</p> RETURNS DESCRIPTION <code>dict</code> <p>mappers metadata</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_bind_mappers_metadata(self) -&gt; Mapping[str, MetaData]:\n    \"\"\"\n    Returns the mappers metadata in a format that can be used\n    in Alembic configuration\n\n    :returns: mappers metadata\n    :rtype: dict\n    \"\"\"\n    return {k: b.registry_mapper.metadata for k, b in self.__binds.items()}\n</code></pre>"},{"location":"API-Reference/_session_handler/","title":"session handler","text":""},{"location":"API-Reference/_session_handler/#sqlalchemy_bind_manager._session_handler.AsyncSessionHandler","title":"<code>AsyncSessionHandler</code>","text":"Source code in <code>sqlalchemy_bind_manager/_session_handler.py</code> <pre><code>class AsyncSessionHandler:\n    scoped_session: async_scoped_session\n\n    def __init__(self, bind: SQLAlchemyAsyncBind):\n        if not isinstance(bind, SQLAlchemyAsyncBind):\n            raise UnsupportedBindError(\"Bind is not an instance of SQLAlchemyAsyncBind\")\n        else:\n            self.scoped_session = async_scoped_session(\n                bind.session_class, asyncio.current_task\n            )\n\n    def __del__(self):\n        if not getattr(self, \"scoped_session\", None):\n            return\n\n        try:\n            loop = asyncio.get_event_loop()\n            if loop.is_running():\n                task = loop.create_task(self.scoped_session.remove())\n                # Add task to the set. This creates a strong reference.\n                _background_asyncio_tasks.add(task)\n\n                # To prevent keeping references to finished tasks forever,\n                # make each task remove its own reference from the set after\n                # completion:\n                task.add_done_callback(_background_asyncio_tasks.discard)\n            else:\n                loop.run_until_complete(self.scoped_session.remove())\n        except RuntimeError:\n            asyncio.run(self.scoped_session.remove())\n\n    @asynccontextmanager\n    async def get_session(self, read_only: bool = False) -&gt; AsyncIterator[AsyncSession]:\n        session = self.scoped_session()\n        try:\n            await session.begin()\n            yield session\n            if not read_only:\n                await self.commit(session)\n        finally:\n            await session.close()\n\n    async def commit(self, session: AsyncSession) -&gt; None:\n        \"\"\"Commits the session and handles rollback on errors.\n\n        :param session: The session object.\n        :type session: AsyncSession\n        :raises Exception: Any error is re-raised after the rollback.\n        \"\"\"\n        try:\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n</code></pre>"},{"location":"API-Reference/_session_handler/#sqlalchemy_bind_manager._session_handler.AsyncSessionHandler.commit","title":"<code>commit(session)</code>  <code>async</code>","text":"<p>Commits the session and handles rollback on errors.</p> PARAMETER  DESCRIPTION <code>session</code> <p>The session object.</p> <p> TYPE: <code>AsyncSession</code> </p> RAISES DESCRIPTION <code>Exception</code> <p>Any error is re-raised after the rollback.</p> Source code in <code>sqlalchemy_bind_manager/_session_handler.py</code> <pre><code>async def commit(self, session: AsyncSession) -&gt; None:\n    \"\"\"Commits the session and handles rollback on errors.\n\n    :param session: The session object.\n    :type session: AsyncSession\n    :raises Exception: Any error is re-raised after the rollback.\n    \"\"\"\n    try:\n        await session.commit()\n    except:\n        await session.rollback()\n        raise\n</code></pre>"},{"location":"API-Reference/_session_handler/#sqlalchemy_bind_manager._session_handler.SessionHandler","title":"<code>SessionHandler</code>","text":"Source code in <code>sqlalchemy_bind_manager/_session_handler.py</code> <pre><code>class SessionHandler:\n    scoped_session: scoped_session\n\n    def __init__(self, bind: SQLAlchemyBind):\n        if not isinstance(bind, SQLAlchemyBind):\n            raise UnsupportedBindError(\"Bind is not an instance of SQLAlchemyBind\")\n        else:\n            self.scoped_session = scoped_session(bind.session_class)\n\n    def __del__(self):\n        if getattr(self, \"scoped_session\", None):\n            self.scoped_session.remove()\n\n    @contextmanager\n    def get_session(self, read_only: bool = False) -&gt; Iterator[Session]:\n        session = self.scoped_session()\n        try:\n            session.begin()\n            yield session\n            if not read_only:\n                self.commit(session)\n        finally:\n            session.close()\n\n    def commit(self, session: Session) -&gt; None:\n        \"\"\"Commits the session and handles rollback on errors.\n\n        :param session: The session object.\n        :type session: Session\n        :raises Exception: Any error is re-raised after the rollback.\n        \"\"\"\n        try:\n            session.commit()\n        except:\n            session.rollback()\n            raise\n</code></pre>"},{"location":"API-Reference/_session_handler/#sqlalchemy_bind_manager._session_handler.SessionHandler.commit","title":"<code>commit(session)</code>","text":"<p>Commits the session and handles rollback on errors.</p> PARAMETER  DESCRIPTION <code>session</code> <p>The session object.</p> <p> TYPE: <code>Session</code> </p> RAISES DESCRIPTION <code>Exception</code> <p>Any error is re-raised after the rollback.</p> Source code in <code>sqlalchemy_bind_manager/_session_handler.py</code> <pre><code>def commit(self, session: Session) -&gt; None:\n    \"\"\"Commits the session and handles rollback on errors.\n\n    :param session: The session object.\n    :type session: Session\n    :raises Exception: Any error is re-raised after the rollback.\n    \"\"\"\n    try:\n        session.commit()\n    except:\n        session.rollback()\n        raise\n</code></pre>"},{"location":"API-Reference/exceptions/","title":"Exceptions","text":""},{"location":"API-Reference/protocols/","title":"Protocols","text":""},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface","title":"<code>SQLAlchemyAsyncRepositoryInterface</code>","text":"<p>             Bases: <code>Protocol[MODEL]</code></p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>@runtime_checkable\nclass SQLAlchemyAsyncRepositoryInterface(Protocol[MODEL]):\n    async def save(self, instance: MODEL) -&gt; MODEL:\n        \"\"\"Persist a model.\n\n        :param instance: A mapped object instance to be persisted\n        :return: The model instance after being persisted\n        \"\"\"\n        ...\n\n    async def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n        \"\"\"Persist many models in a single database get_session.\n\n        :param instances: A list of mapped objects to be persisted\n        :type instances: Iterable\n        :return: The model instances after being persisted\n        \"\"\"\n        ...\n\n    async def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n        \"\"\"Get a model by primary key.\n\n        :param identifier: The primary key\n        :return: A model instance\n        :raises ModelNotFoundError: No model has been found using the primary key\n        \"\"\"\n        ...\n\n    async def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n        \"\"\"Get a list of models by primary keys.\n\n        :param identifiers: A list of primary keys\n        :type identifiers: List\n        :return: A list of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    async def delete(self, instance: MODEL) -&gt; None:\n        \"\"\"Deletes a model.\n\n        :param instance: The model instance\n        \"\"\"\n        ...\n\n    async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n        \"\"\"Deletes a collection of models in a single transaction.\n\n        :param instances: The model instances\n        \"\"\"\n        ...\n\n    async def find(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; List[MODEL]:\n        \"\"\"Find models using filters.\n\n        E.g.\n        find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        find(order_by=[\"name\"])\n            finds all models ordered by `name` column\n\n        find(order_by=[(\"name\", SortDirection.DESC)])\n            finds all models with reversed order by `name` column\n\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :param order_by:\n        :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    async def paginated_find(\n        self,\n        items_per_page: int,\n        page: int = 1,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; PaginatedResult[MODEL]:\n        \"\"\"Find models using filters and limit/offset pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n        paginated_find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        paginated_find(50, search_params={\"name\":\"John\"})\n            finds first 50 models with name = John\n\n        paginated_find(50, 3, search_params={\"name\":\"John\"})\n            finds 50 models with name = John, skipping 2 pages (100)\n\n        paginated_find(order_by=[\"name\"])\n            finds all models ordered by `name` column\n\n        paginated_find(order_by=[(\"name\", SortDirection.DESC)])\n            finds all models with reversed order by `name` column\n\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :param page: Page to retrieve\n        :type page: int\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :param order_by:\n        :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    async def cursor_paginated_find(\n        self,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None] = None,\n        is_before_cursor: bool = False,\n        search_params: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; CursorPaginatedResult[MODEL]:\n        \"\"\"Find models using filters and cursor based pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n        cursor_paginated_find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        cursor_paginated_find(50, search_params={\"name\":\"John\"})\n            finds first 50 models with name = John\n\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n            finds first 50 models after the one with \"id\" 123\n\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n            finds last 50 models before the one with \"id\" 123\n\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :type cursor_reference: Union[CursorReference, None]\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :type is_before_cursor: bool\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.cursor_paginated_find","title":"<code>cursor_paginated_find(items_per_page, cursor_reference=None, is_before_cursor=False, search_params=None)</code>  <code>async</code>","text":"<p>Find models using filters and cursor based pagination. Returned results do include pagination metadata.</p> <p>E.g. cursor_paginated_find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>cursor_paginated_find(50, search_params={\"name\":\"John\"})     finds first 50 models with name = John</p> <p>cursor_paginated_find(50, CursorReference(column=\"id\", value=123))     finds first 50 models after the one with \"id\" 123</p> <p>cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)     finds last 50 models before the one with \"id\" 123</p> PARAMETER  DESCRIPTION <code>items_per_page</code> <p>Number of models to retrieve</p> <p> TYPE: <code>int</code> </p> <code>cursor_reference</code> <p>A cursor reference containing ordering column and threshold value</p> <p> TYPE: <code>Union[CursorReference, None]</code> DEFAULT: <code>None</code> </p> <code>is_before_cursor</code> <p>If True it will return items before the cursor, otherwise items after</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def cursor_paginated_find(\n    self,\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]:\n    \"\"\"Find models using filters and cursor based pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n    cursor_paginated_find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    cursor_paginated_find(50, search_params={\"name\":\"John\"})\n        finds first 50 models with name = John\n\n    cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n        finds first 50 models after the one with \"id\" 123\n\n    cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n        finds last 50 models before the one with \"id\" 123\n\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.delete","title":"<code>delete(instance)</code>  <code>async</code>","text":"<p>Deletes a model.</p> PARAMETER  DESCRIPTION <code>instance</code> <p>The model instance</p> <p> TYPE: <code>MODEL</code> </p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def delete(self, instance: MODEL) -&gt; None:\n    \"\"\"Deletes a model.\n\n    :param instance: The model instance\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.delete_many","title":"<code>delete_many(instances)</code>  <code>async</code>","text":"<p>Deletes a collection of models in a single transaction.</p> PARAMETER  DESCRIPTION <code>instances</code> <p>The model instances</p> <p> TYPE: <code>Iterable[MODEL]</code> </p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n    \"\"\"Deletes a collection of models in a single transaction.\n\n    :param instances: The model instances\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.find","title":"<code>find(search_params=None, order_by=None)</code>  <code>async</code>","text":"<p>Find models using filters.</p> <p>E.g. find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>find(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>find(order_by=[(\"name\", SortDirection.DESC)])     finds all models with reversed order by <code>name</code> column</p> PARAMETER  DESCRIPTION <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>order_by</code> <p> TYPE: <code>Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def find(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n) -&gt; List[MODEL]:\n    \"\"\"Find models using filters.\n\n    E.g.\n    find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    find(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    find(order_by=[(\"name\", SortDirection.DESC)])\n        finds all models with reversed order by `name` column\n\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :param order_by:\n    :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.get","title":"<code>get(identifier)</code>  <code>async</code>","text":"<p>Get a model by primary key.</p> PARAMETER  DESCRIPTION <code>identifier</code> <p>The primary key</p> <p> TYPE: <code>PRIMARY_KEY</code> </p> RETURNS DESCRIPTION <code>MODEL</code> <p>A model instance</p> RAISES DESCRIPTION <code>ModelNotFoundError</code> <p>No model has been found using the primary key</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n    \"\"\"Get a model by primary key.\n\n    :param identifier: The primary key\n    :return: A model instance\n    :raises ModelNotFoundError: No model has been found using the primary key\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.get_many","title":"<code>get_many(identifiers)</code>  <code>async</code>","text":"<p>Get a list of models by primary keys.</p> PARAMETER  DESCRIPTION <code>identifiers</code> <p>A list of primary keys</p> <p> TYPE: <code>Iterable[PRIMARY_KEY]</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A list of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n    \"\"\"Get a list of models by primary keys.\n\n    :param identifiers: A list of primary keys\n    :type identifiers: List\n    :return: A list of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.paginated_find","title":"<code>paginated_find(items_per_page, page=1, search_params=None, order_by=None)</code>  <code>async</code>","text":"<p>Find models using filters and limit/offset pagination. Returned results do include pagination metadata.</p> <p>E.g. paginated_find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>paginated_find(50, search_params={\"name\":\"John\"})     finds first 50 models with name = John</p> <p>paginated_find(50, 3, search_params={\"name\":\"John\"})     finds 50 models with name = John, skipping 2 pages (100)</p> <p>paginated_find(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>paginated_find(order_by=[(\"name\", SortDirection.DESC)])     finds all models with reversed order by <code>name</code> column</p> PARAMETER  DESCRIPTION <code>items_per_page</code> <p>Number of models to retrieve</p> <p> TYPE: <code>int</code> </p> <code>page</code> <p>Page to retrieve</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>order_by</code> <p> TYPE: <code>Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def paginated_find(\n    self,\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n) -&gt; PaginatedResult[MODEL]:\n    \"\"\"Find models using filters and limit/offset pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n    paginated_find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    paginated_find(50, search_params={\"name\":\"John\"})\n        finds first 50 models with name = John\n\n    paginated_find(50, 3, search_params={\"name\":\"John\"})\n        finds 50 models with name = John, skipping 2 pages (100)\n\n    paginated_find(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    paginated_find(order_by=[(\"name\", SortDirection.DESC)])\n        finds all models with reversed order by `name` column\n\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :param page: Page to retrieve\n    :type page: int\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :param order_by:\n    :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.save","title":"<code>save(instance)</code>  <code>async</code>","text":"<p>Persist a model.</p> PARAMETER  DESCRIPTION <code>instance</code> <p>A mapped object instance to be persisted</p> <p> TYPE: <code>MODEL</code> </p> RETURNS DESCRIPTION <code>MODEL</code> <p>The model instance after being persisted</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def save(self, instance: MODEL) -&gt; MODEL:\n    \"\"\"Persist a model.\n\n    :param instance: A mapped object instance to be persisted\n    :return: The model instance after being persisted\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyAsyncRepositoryInterface.save_many","title":"<code>save_many(instances)</code>  <code>async</code>","text":"<p>Persist many models in a single database get_session.</p> PARAMETER  DESCRIPTION <code>instances</code> <p>A list of mapped objects to be persisted</p> <p> TYPE: <code>Iterable[MODEL]</code> </p> RETURNS DESCRIPTION <code>Iterable[MODEL]</code> <p>The model instances after being persisted</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n    \"\"\"Persist many models in a single database get_session.\n\n    :param instances: A list of mapped objects to be persisted\n    :type instances: Iterable\n    :return: The model instances after being persisted\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface","title":"<code>SQLAlchemyRepositoryInterface</code>","text":"<p>             Bases: <code>Protocol[MODEL]</code></p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>@runtime_checkable\nclass SQLAlchemyRepositoryInterface(Protocol[MODEL]):\n    def save(self, instance: MODEL) -&gt; MODEL:\n        \"\"\"Persist a model.\n\n        :param instance: A mapped object instance to be persisted\n        :return: The model instance after being persisted\n        \"\"\"\n        ...\n\n    def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n        \"\"\"Persist many models in a single database get_session.\n\n        :param instances: A list of mapped objects to be persisted\n        :type instances: Iterable\n        :return: The model instances after being persisted\n        \"\"\"\n        ...\n\n    def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n        \"\"\"Get a model by primary key.\n\n        :param identifier: The primary key\n        :return: A model instance\n        :raises ModelNotFoundError: No model has been found using the primary key\n        \"\"\"\n        ...\n\n    def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n        \"\"\"Get a list of models by primary keys.\n\n        :param identifiers: A list of primary keys\n        :type identifiers: List\n        :return: A list of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    def delete(self, instance: MODEL) -&gt; None:\n        \"\"\"Deletes a model.\n\n        :param instance: The model instance\n        \"\"\"\n        ...\n\n    async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n        \"\"\"Deletes a collection of models in a single transaction.\n\n        :param instances: The model instances\n        \"\"\"\n        ...\n\n    def find(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; List[MODEL]:\n        \"\"\"Find models using filters.\n\n        E.g.\n        find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        find(order_by=[\"name\"])\n            finds all models ordered by `name` column\n\n        find(order_by=[(\"name\", SortDirection.DESC)])\n            finds all models with reversed order by `name` column\n\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :param order_by:\n        :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    def paginated_find(\n        self,\n        items_per_page: int,\n        page: int = 1,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; PaginatedResult[MODEL]:\n        \"\"\"Find models using filters and limit/offset pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n        paginated_find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        paginated_find(50, search_params={\"name\":\"John\"})\n            finds first 50 models with name = John\n\n        paginated_find(50, 3, search_params={\"name\":\"John\"})\n            finds 50 models with name = John, skipping 2 pages (100)\n\n        paginated_find(order_by=[\"name\"])\n            finds all models ordered by `name` column\n\n        paginated_find(order_by=[(\"name\", SortDirection.DESC)])\n            finds all models with reversed order by `name` column\n\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :param page: Page to retrieve\n        :type page: int\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :param order_by:\n        :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n\n    def cursor_paginated_find(\n        self,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None] = None,\n        is_before_cursor: bool = False,\n        search_params: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; CursorPaginatedResult[MODEL]:\n        \"\"\"Find models using filters and cursor based pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n        cursor_paginated_find(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        cursor_paginated_find(50, search_params={\"name\":\"John\"})\n            finds first 50 models with name = John\n\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n            finds first 50 models after the one with \"id\" 123\n\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n            finds last 50 models before the one with \"id\" 123\n\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :type cursor_reference: Union[CursorReference, None]\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :type is_before_cursor: bool\n        :param search_params: A mapping containing equality filters\n        :type search_params: Mapping\n        :return: A collection of models\n        :rtype: List\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.cursor_paginated_find","title":"<code>cursor_paginated_find(items_per_page, cursor_reference=None, is_before_cursor=False, search_params=None)</code>","text":"<p>Find models using filters and cursor based pagination. Returned results do include pagination metadata.</p> <p>E.g. cursor_paginated_find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>cursor_paginated_find(50, search_params={\"name\":\"John\"})     finds first 50 models with name = John</p> <p>cursor_paginated_find(50, CursorReference(column=\"id\", value=123))     finds first 50 models after the one with \"id\" 123</p> <p>cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)     finds last 50 models before the one with \"id\" 123</p> PARAMETER  DESCRIPTION <code>items_per_page</code> <p>Number of models to retrieve</p> <p> TYPE: <code>int</code> </p> <code>cursor_reference</code> <p>A cursor reference containing ordering column and threshold value</p> <p> TYPE: <code>Union[CursorReference, None]</code> DEFAULT: <code>None</code> </p> <code>is_before_cursor</code> <p>If True it will return items before the cursor, otherwise items after</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def cursor_paginated_find(\n    self,\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]:\n    \"\"\"Find models using filters and cursor based pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n    cursor_paginated_find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    cursor_paginated_find(50, search_params={\"name\":\"John\"})\n        finds first 50 models with name = John\n\n    cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n        finds first 50 models after the one with \"id\" 123\n\n    cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n        finds last 50 models before the one with \"id\" 123\n\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.delete","title":"<code>delete(instance)</code>","text":"<p>Deletes a model.</p> PARAMETER  DESCRIPTION <code>instance</code> <p>The model instance</p> <p> TYPE: <code>MODEL</code> </p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def delete(self, instance: MODEL) -&gt; None:\n    \"\"\"Deletes a model.\n\n    :param instance: The model instance\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.delete_many","title":"<code>delete_many(instances)</code>  <code>async</code>","text":"<p>Deletes a collection of models in a single transaction.</p> PARAMETER  DESCRIPTION <code>instances</code> <p>The model instances</p> <p> TYPE: <code>Iterable[MODEL]</code> </p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n    \"\"\"Deletes a collection of models in a single transaction.\n\n    :param instances: The model instances\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.find","title":"<code>find(search_params=None, order_by=None)</code>","text":"<p>Find models using filters.</p> <p>E.g. find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>find(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>find(order_by=[(\"name\", SortDirection.DESC)])     finds all models with reversed order by <code>name</code> column</p> PARAMETER  DESCRIPTION <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>order_by</code> <p> TYPE: <code>Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def find(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n) -&gt; List[MODEL]:\n    \"\"\"Find models using filters.\n\n    E.g.\n    find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    find(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    find(order_by=[(\"name\", SortDirection.DESC)])\n        finds all models with reversed order by `name` column\n\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :param order_by:\n    :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.get","title":"<code>get(identifier)</code>","text":"<p>Get a model by primary key.</p> PARAMETER  DESCRIPTION <code>identifier</code> <p>The primary key</p> <p> TYPE: <code>PRIMARY_KEY</code> </p> RETURNS DESCRIPTION <code>MODEL</code> <p>A model instance</p> RAISES DESCRIPTION <code>ModelNotFoundError</code> <p>No model has been found using the primary key</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n    \"\"\"Get a model by primary key.\n\n    :param identifier: The primary key\n    :return: A model instance\n    :raises ModelNotFoundError: No model has been found using the primary key\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.get_many","title":"<code>get_many(identifiers)</code>","text":"<p>Get a list of models by primary keys.</p> PARAMETER  DESCRIPTION <code>identifiers</code> <p>A list of primary keys</p> <p> TYPE: <code>Iterable[PRIMARY_KEY]</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A list of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n    \"\"\"Get a list of models by primary keys.\n\n    :param identifiers: A list of primary keys\n    :type identifiers: List\n    :return: A list of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.paginated_find","title":"<code>paginated_find(items_per_page, page=1, search_params=None, order_by=None)</code>","text":"<p>Find models using filters and limit/offset pagination. Returned results do include pagination metadata.</p> <p>E.g. paginated_find(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>paginated_find(50, search_params={\"name\":\"John\"})     finds first 50 models with name = John</p> <p>paginated_find(50, 3, search_params={\"name\":\"John\"})     finds 50 models with name = John, skipping 2 pages (100)</p> <p>paginated_find(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>paginated_find(order_by=[(\"name\", SortDirection.DESC)])     finds all models with reversed order by <code>name</code> column</p> PARAMETER  DESCRIPTION <code>items_per_page</code> <p>Number of models to retrieve</p> <p> TYPE: <code>int</code> </p> <code>page</code> <p>Page to retrieve</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>search_params</code> <p>A mapping containing equality filters</p> <p> TYPE: <code>Union[None, Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>order_by</code> <p> TYPE: <code>Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def paginated_find(\n    self,\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n) -&gt; PaginatedResult[MODEL]:\n    \"\"\"Find models using filters and limit/offset pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n    paginated_find(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    paginated_find(50, search_params={\"name\":\"John\"})\n        finds first 50 models with name = John\n\n    paginated_find(50, 3, search_params={\"name\":\"John\"})\n        finds 50 models with name = John, skipping 2 pages (100)\n\n    paginated_find(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    paginated_find(order_by=[(\"name\", SortDirection.DESC)])\n        finds all models with reversed order by `name` column\n\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :param page: Page to retrieve\n    :type page: int\n    :param search_params: A mapping containing equality filters\n    :type search_params: Mapping\n    :param order_by:\n    :type order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]]\n    :return: A collection of models\n    :rtype: List\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.save","title":"<code>save(instance)</code>","text":"<p>Persist a model.</p> PARAMETER  DESCRIPTION <code>instance</code> <p>A mapped object instance to be persisted</p> <p> TYPE: <code>MODEL</code> </p> RETURNS DESCRIPTION <code>MODEL</code> <p>The model instance after being persisted</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def save(self, instance: MODEL) -&gt; MODEL:\n    \"\"\"Persist a model.\n\n    :param instance: A mapped object instance to be persisted\n    :return: The model instance after being persisted\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/protocols/#sqlalchemy_bind_manager.protocols.SQLAlchemyRepositoryInterface.save_many","title":"<code>save_many(instances)</code>","text":"<p>Persist many models in a single database get_session.</p> PARAMETER  DESCRIPTION <code>instances</code> <p>A list of mapped objects to be persisted</p> <p> TYPE: <code>Iterable[MODEL]</code> </p> RETURNS DESCRIPTION <code>Iterable[MODEL]</code> <p>The model instances after being persisted</p> Source code in <code>sqlalchemy_bind_manager/protocols.py</code> <pre><code>def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n    \"\"\"Persist many models in a single database get_session.\n\n    :param instances: A list of mapped objects to be persisted\n    :type instances: Iterable\n    :return: The model instances after being persisted\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API-Reference/repository/","title":"Repository","text":""},{"location":"API-Reference/_repository/","title":"Index","text":""},{"location":"API-Reference/_repository/async_/","title":"Async","text":""},{"location":"API-Reference/_repository/async_/#sqlalchemy_bind_manager._repository.async_.SQLAlchemyAsyncRepository","title":"<code>SQLAlchemyAsyncRepository</code>","text":"<p>             Bases: <code>Generic[MODEL]</code>, <code>BaseRepository[MODEL]</code>, <code>ABC</code></p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>class SQLAlchemyAsyncRepository(Generic[MODEL], BaseRepository[MODEL], ABC):\n    _session_handler: AsyncSessionHandler\n    _external_session: Union[AsyncSession, None]\n\n    def __init__(\n        self,\n        bind: Union[SQLAlchemyAsyncBind, None] = None,\n        session: Union[AsyncSession, None] = None,\n        model_class: Union[Type[MODEL], None] = None,\n    ) -&gt; None:\n        \"\"\"\n        :param bind: A configured instance of SQLAlchemyAsyncBind\n        :type bind: Union[SQLAlchemyAsyncBind, None]\n        :param session: An externally managed session\n        :type session: Union[AsyncSession, None]\n        :param model_class: A mapped SQLAlchemy model\n        :type model_class: Union[Type[MODEL], None]\n        \"\"\"\n        super().__init__(model_class=model_class)\n        if not (bool(bind) ^ bool(session)):\n            raise InvalidConfigError(\n                \"Either `bind` or `session` have to be used, not both\"\n            )\n        self._external_session = session\n        if bind:\n            self._session_handler = AsyncSessionHandler(bind)\n\n    @asynccontextmanager\n    async def _get_session(self, commit: bool = True) -&gt; AsyncIterator[AsyncSession]:\n        if not self._external_session:\n            async with self._session_handler.get_session(not commit) as _session:\n                yield _session\n        else:\n            yield self._external_session\n\n    async def save(self, instance: MODEL) -&gt; MODEL:\n        self._fail_if_invalid_models([instance])\n        async with self._get_session() as session:\n            session.add(instance)\n        return instance\n\n    async def save_many(\n        self,\n        instances: Iterable[MODEL],\n    ) -&gt; Iterable[MODEL]:\n        self._fail_if_invalid_models(instances)\n        async with self._get_session() as session:\n            session.add_all(instances)\n        return instances\n\n    async def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n        async with self._get_session(commit=False) as session:\n            model = await session.get(self._model, identifier)\n        if model is None:\n            raise ModelNotFoundError(\"No rows found for provided primary key.\")\n        return model\n\n    async def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n        stmt = select(self._model).where(\n            getattr(self._model, self._model_pk()).in_(identifiers)\n        )\n\n        async with self._get_session(commit=False) as session:\n            return [x for x in (await session.execute(stmt)).scalars()]\n\n    async def delete(self, instance: MODEL) -&gt; None:\n        self._fail_if_invalid_models([instance])\n        async with self._get_session() as session:\n            await session.delete(instance)\n\n    async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n        self._fail_if_invalid_models(instances)\n        async with self._get_session() as session:\n            for instance in instances:\n                await session.delete(instance)\n\n    async def find(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; List[MODEL]:\n        stmt = self._find_query(search_params, order_by)\n\n        async with self._get_session() as session:\n            result = await session.execute(stmt)\n            return [x for x in result.scalars()]\n\n    async def paginated_find(\n        self,\n        items_per_page: int,\n        page: int = 1,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; PaginatedResult[MODEL]:\n        find_stmt = self._find_query(search_params, order_by)\n        paginated_stmt = self._paginate_query_by_page(find_stmt, page, items_per_page)\n\n        async with self._get_session() as session:\n            total_items_count = (\n                await session.execute(self._count_query(find_stmt))\n            ).scalar() or 0\n            result_items = [\n                x for x in (await session.execute(paginated_stmt)).scalars()\n            ]\n\n            return PaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                page=page,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n            )\n\n    async def cursor_paginated_find(\n        self,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None] = None,\n        is_before_cursor: bool = False,\n        search_params: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; CursorPaginatedResult[MODEL]:\n        find_stmt = self._find_query(search_params)\n        paginated_stmt = self._cursor_paginated_query(\n            find_stmt,\n            cursor_reference=cursor_reference,\n            is_before_cursor=is_before_cursor,\n            items_per_page=items_per_page,\n        )\n\n        async with self._get_session() as session:\n            total_items_count = (\n                await session.execute(self._count_query(find_stmt))\n            ).scalar() or 0\n            result_items = [\n                x for x in (await session.execute(paginated_stmt)).scalars()\n            ] or []\n\n            return CursorPaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n                cursor_reference=cursor_reference,\n                is_before_cursor=is_before_cursor,\n            )\n</code></pre>"},{"location":"API-Reference/_repository/async_/#sqlalchemy_bind_manager._repository.async_.SQLAlchemyAsyncRepository.__init__","title":"<code>__init__(bind=None, session=None, model_class=None)</code>","text":"PARAMETER  DESCRIPTION <code>bind</code> <p>A configured instance of SQLAlchemyAsyncBind</p> <p> TYPE: <code>Union[SQLAlchemyAsyncBind, None]</code> DEFAULT: <code>None</code> </p> <code>session</code> <p>An externally managed session</p> <p> TYPE: <code>Union[AsyncSession, None]</code> DEFAULT: <code>None</code> </p> <code>model_class</code> <p>A mapped SQLAlchemy model</p> <p> TYPE: <code>Union[Type[MODEL], None]</code> DEFAULT: <code>None</code> </p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>def __init__(\n    self,\n    bind: Union[SQLAlchemyAsyncBind, None] = None,\n    session: Union[AsyncSession, None] = None,\n    model_class: Union[Type[MODEL], None] = None,\n) -&gt; None:\n    \"\"\"\n    :param bind: A configured instance of SQLAlchemyAsyncBind\n    :type bind: Union[SQLAlchemyAsyncBind, None]\n    :param session: An externally managed session\n    :type session: Union[AsyncSession, None]\n    :param model_class: A mapped SQLAlchemy model\n    :type model_class: Union[Type[MODEL], None]\n    \"\"\"\n    super().__init__(model_class=model_class)\n    if not (bool(bind) ^ bool(session)):\n        raise InvalidConfigError(\n            \"Either `bind` or `session` have to be used, not both\"\n        )\n    self._external_session = session\n    if bind:\n        self._session_handler = AsyncSessionHandler(bind)\n</code></pre>"},{"location":"API-Reference/_repository/base_repository/","title":"Base repository","text":""},{"location":"API-Reference/_repository/base_repository/#sqlalchemy_bind_manager._repository.base_repository.BaseRepository","title":"<code>BaseRepository</code>","text":"<p>             Bases: <code>Generic[MODEL]</code>, <code>ABC</code></p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>class BaseRepository(Generic[MODEL], ABC):\n    _max_query_limit: int = 50\n    _model: Type[MODEL]\n\n    def __init__(self, model_class: Union[Type[MODEL], None] = None) -&gt; None:\n        if getattr(self, \"_model\", None) is None and model_class is not None:\n            self._model = model_class\n\n        if getattr(self, \"_model\", None) is None or not self._is_mapped_class(\n            self._model\n        ):\n            raise InvalidModelError(\n                \"You need to supply a valid model class\"\n                \" either in the `model_class` parameter\"\n                \" or in the `_model` class property.\"\n            )\n\n    def _is_mapped_class(self, class_: Type[MODEL]) -&gt; bool:\n        \"\"\"Checks if the class is mapped in SQLAlchemy.\n\n        :param class_: the model class\n        :return: True if the Type is mapped, False otherwise\n        :rtype: bool\n        \"\"\"\n        try:\n            class_mapper(class_)\n            return True\n        except UnmappedClassError:\n            return False\n\n    def _validate_mapped_property(self, property_name: str) -&gt; None:\n        \"\"\"Checks if a property is mapped in the model class.\n\n        :param property_name: The name of the property to be evaluated.\n        :type property_name: str\n        :raises UnmappedPropertyError: When the property is not mapped.\n        \"\"\"\n        m: Mapper = class_mapper(self._model)\n        if property_name not in m.column_attrs:\n            raise UnmappedPropertyError(\n                f\"Property `{property_name}` is not mapped\"\n                f\" in the ORM for model `{self._model}`\"\n            )\n\n    def _filter_select(self, stmt: Select, search_params: Mapping[str, Any]) -&gt; Select:\n        \"\"\"Build the query filtering clauses from submitted parameters.\n\n        E.g.\n        _filter_select(stmt, name=\"John\") adds a `WHERE name = John` statement\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param search_params: Any keyword argument to be used as equality filter\n        :type search_params: Mapping[str, Any]\n        :return: The filtered query\n        \"\"\"\n        # TODO: Add support for relationship eager load\n        for k, v in search_params.items():\n            \"\"\"\n            This acts as a TypeGuard but using TypeGuard typing would break\n            compatibility with python &lt; 3.10, for the moment we prefer to ignore\n            typing issues here\n            \"\"\"\n            self._validate_mapped_property(k)\n            stmt = stmt.where(getattr(self._model, k) == v)\n        return stmt\n\n    def _filter_order_by(\n        self, stmt: Select, order_by: Iterable[Union[str, Tuple[str, SortDirection]]]\n    ) -&gt; Select:\n        \"\"\"Build the query ordering clauses from submitted parameters.\n\n        E.g.\n        `_filter_order_by(stmt, ['name'])`\n            adds a `ORDER BY name` statement\n\n        `_filter_order_by(stmt, [('name', SortDirection.ASC)])`\n            adds a `ORDER BY name ASC` statement\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param order_by: a list of columns, or tuples (column, direction)\n        :type order_by: Iterable[Union[str, Tuple[str, SortDirection]]]\n        :return: The filtered query\n        \"\"\"\n        for value in order_by:\n            if isinstance(value, str):\n                self._validate_mapped_property(value)\n                stmt = stmt.order_by(getattr(self._model, value))\n            else:\n                self._validate_mapped_property(value[0])\n                stmt = stmt.order_by(value[1].value(getattr(self._model, value[0])))\n\n        return stmt\n\n    def _find_query(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[None, Iterable[Union[str, Tuple[str, SortDirection]]]] = None,\n    ) -&gt; Select:\n        \"\"\"Build a query with column filters and orders.\n\n        E.g.\n        q = _find_query(search_params={\"name\":\"John\"})\n            finds all models with name = John\n\n        q = _find_query(order_by=[\"name\"])\n            finds all models ordered by `name` column\n\n        q = _find_query(order_by=[(\"name\", SortDirection.DESC)])\n            finds all models with reversed order by `name` column\n\n        :param search_params: Any keyword argument to be used as equality filter\n        :type search_params: Mapping[str, Any]\n        :param order_by: a list of columns, or tuples (column, direction)\n        :type order_by: Iterable[Union[str, Tuple[str, SortDirection]]]\n        :return: The filtered query\n        \"\"\"\n        stmt = select(self._model)\n\n        if search_params:\n            stmt = self._filter_select(stmt, search_params)\n        if order_by is not None:\n            stmt = self._filter_order_by(stmt, order_by)\n\n        return stmt\n\n    def _count_query(\n        self,\n        query: Select,\n    ) -&gt; Select:\n        return select(func.count()).select_from(\n            query.options(lazyload(\"*\")).subquery()  # type: ignore\n        )\n\n    def _paginate_query_by_page(\n        self,\n        stmt: Select,\n        page: int,\n        items_per_page: int,\n    ) -&gt; Select:\n        \"\"\"Build the query offset and limit clauses from submitted parameters.\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param page: Number of models to skip\n        :type page: int\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :return: The filtered query\n        \"\"\"\n\n        _offset = max((page - 1) * items_per_page, 0)\n        if _offset &gt; 0:\n            stmt = stmt.offset(_offset)\n\n        _limit = self._sanitised_query_limit(items_per_page)\n        stmt = stmt.limit(_limit)\n\n        return stmt\n\n    def _cursor_paginated_query(\n        self,\n        stmt: Select,\n        cursor_reference: Union[CursorReference, None],\n        is_before_cursor: bool = False,\n        items_per_page: int = _max_query_limit,\n    ) -&gt; Select:\n        \"\"\"Adds the clauses to retrieve the requested slice of models, after\n        or before the cursor value, plus a model before the slice and one after\n        the slice, to identify if previous or next results are available.\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :type cursor_reference: Union[CursorReference, None]\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :type is_before_cursor: bool\n        :param items_per_page: Number of models to retrieve\n        :type items_per_page: int\n        :return: The filtered query\n        \"\"\"\n        forward_limit = self._sanitised_query_limit(items_per_page) + 1\n\n        if not cursor_reference:\n            return stmt.limit(forward_limit).order_by(  # type: ignore\n                asc(self._model_pk())\n            )\n\n        previous_query = self._cursor_pagination_previous_item_query(\n            stmt, cursor_reference, is_before_cursor\n        ).subquery(\"previous\")\n\n        page_query = self._cursor_pagination_slice_query(\n            stmt, cursor_reference, forward_limit, is_before_cursor\n        ).subquery(\"slice\")\n\n        query = select(\n            aliased(\n                self._model,\n                select(previous_query)\n                .union_all(select(page_query))\n                .order_by(cursor_reference.column)\n                .subquery(\"cursor_pagination\"),  # type: ignore\n            )\n        )\n        return query\n\n    def _cursor_pagination_slice_query(\n        self,\n        stmt: Select,\n        cursor_reference: CursorReference,\n        limit: int,\n        is_before_cursor: bool,\n    ):\n        \"\"\"Adds the clauses to retrieve a requested slice of models,\n        after or before the cursor value (excluding the cursor itself)\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :type cursor_reference: Union[CursorReference, None]\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :type is_before_cursor: bool\n        :param limit: Number of models to retrieve\n        :type limit: int\n        :return: The filtered query\n        \"\"\"\n        if not is_before_cursor:\n            page_query = stmt.where(\n                getattr(self._model, cursor_reference.column) &gt; cursor_reference.value\n            )\n            page_query = self._filter_order_by(\n                page_query, [(cursor_reference.column, SortDirection.ASC)]\n            )\n        else:\n            page_query = stmt.where(\n                getattr(self._model, cursor_reference.column) &lt; cursor_reference.value\n            )\n            page_query = self._filter_order_by(\n                page_query, [(cursor_reference.column, SortDirection.DESC)]\n            )\n        return page_query.limit(limit)\n\n    def _cursor_pagination_previous_item_query(\n        self, stmt: Select, cursor_reference: CursorReference, is_before_cursor: bool\n    ) -&gt; Select:\n        \"\"\"Adds the clauses to retrieve a single model, after or before\n        the cursor value (including the cursor itself).\n\n        :param stmt: a Select statement\n        :type stmt: Select\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :type cursor_reference: Union[CursorReference, None]\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :type is_before_cursor: bool\n        :return: The filtered query\n        \"\"\"\n        if not is_before_cursor:\n            previous_query = stmt.where(\n                getattr(self._model, cursor_reference.column) &lt;= cursor_reference.value\n            )\n            previous_query = self._filter_order_by(\n                previous_query, [(cursor_reference.column, SortDirection.DESC)]\n            )\n        else:\n            previous_query = stmt.where(\n                getattr(self._model, cursor_reference.column) &gt;= cursor_reference.value\n            )\n            previous_query = self._filter_order_by(\n                previous_query, [(cursor_reference.column, SortDirection.ASC)]\n            )\n\n        return previous_query.limit(1)\n\n    def _sanitised_query_limit(self, limit):\n        return max(min(limit, self._max_query_limit), 0)\n\n    def _model_pk(self) -&gt; str:\n        \"\"\"\n        Retrieves the primary key name from the repository model class.\n\n        :return:\n        \"\"\"\n        primary_keys = inspect(self._model).primary_key  # type: ignore\n        if len(primary_keys) &gt; 1:\n            raise NotImplementedError(\"Composite primary keys are not supported.\")\n\n        return primary_keys[0].name\n\n    def _fail_if_invalid_models(self, objects: Iterable[MODEL]) -&gt; None:\n        if [x for x in objects if not isinstance(x, self._model)]:\n            raise InvalidModelError(\n                \"Cannot handle models not belonging to this repository\"\n            )\n</code></pre>"},{"location":"API-Reference/_repository/common/","title":"Common","text":""},{"location":"API-Reference/_repository/result_presenters/","title":"Result presenters","text":""},{"location":"API-Reference/_repository/result_presenters/#sqlalchemy_bind_manager._repository.result_presenters.CursorPaginatedResultPresenter","title":"<code>CursorPaginatedResultPresenter</code>","text":"Source code in <code>sqlalchemy_bind_manager/_repository/result_presenters.py</code> <pre><code>class CursorPaginatedResultPresenter:\n    @classmethod\n    def build_result(\n        cls,\n        result_items: List[MODEL],\n        total_items_count: int,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None],\n        is_before_cursor: bool,\n    ) -&gt; CursorPaginatedResult:\n        \"\"\"\n        Produces a structured paginated result identifying previous/next pages\n        and slicing results accordingly.\n\n        :param result_items:\n        :param total_items_count:\n        :param items_per_page:\n        :param cursor_reference:\n        :param is_before_cursor:\n        :return:\n        \"\"\"\n        if not result_items:\n            return cls._build_empty_items_result(total_items_count, items_per_page)\n\n        if not cursor_reference:\n            return cls._build_no_cursor_result(\n                result_items, total_items_count, items_per_page\n            )\n\n        if is_before_cursor:\n            return cls._build_before_cursor_result(\n                result_items, total_items_count, items_per_page, cursor_reference\n            )\n\n        return cls._build_after_cursor_result(\n            result_items, total_items_count, items_per_page, cursor_reference\n        )\n\n    @staticmethod\n    def _build_empty_items_result(\n        total_items_count: int,\n        items_per_page: int,\n    ) -&gt; CursorPaginatedResult:\n        return CursorPaginatedResult(\n            items=[],\n            page_info=CursorPageInfo(\n                items_per_page=items_per_page,\n                total_items=total_items_count,\n            ),\n        )\n\n    @staticmethod\n    def _build_no_cursor_result(\n        result_items: List[MODEL],\n        total_items_count: int,\n        items_per_page: int,\n    ) -&gt; CursorPaginatedResult:\n        has_next_page = len(result_items) &gt; items_per_page\n        if has_next_page:\n            result_items = result_items[0:items_per_page]\n        reference_column = _pk_from_result_object(result_items[0])\n\n        return CursorPaginatedResult(\n            items=result_items,\n            page_info=CursorPageInfo(\n                items_per_page=items_per_page,\n                total_items=total_items_count,\n                has_previous_page=False,\n                has_next_page=has_next_page,\n                start_cursor=CursorReference(\n                    column=reference_column,\n                    value=getattr(result_items[0], reference_column),\n                ),\n                end_cursor=CursorReference(\n                    column=reference_column,\n                    value=getattr(result_items[-1], reference_column),\n                ),\n            ),\n        )\n\n    @staticmethod\n    def _build_before_cursor_result(\n        result_items: List[MODEL],\n        total_items_count: int,\n        items_per_page: int,\n        cursor_reference: CursorReference,\n    ) -&gt; CursorPaginatedResult:\n        index = -1\n        reference_column = cursor_reference.column\n        last_found_cursor_value = getattr(result_items[index], reference_column)\n        if not isinstance(last_found_cursor_value, type(cursor_reference.value)):\n            raise TypeError(\n                \"Values from CursorReference and results must be of the same type\"\n            )\n        has_next_page = last_found_cursor_value &gt;= cursor_reference.value\n        if has_next_page:\n            result_items.pop(index)\n        has_previous_page = len(result_items) &gt; items_per_page\n        if has_previous_page:\n            result_items = result_items[-items_per_page:]\n\n        return CursorPaginatedResult(\n            items=result_items,\n            page_info=CursorPageInfo(\n                items_per_page=items_per_page,\n                total_items=total_items_count,\n                has_previous_page=has_previous_page,\n                has_next_page=has_next_page,\n                start_cursor=(\n                    CursorReference(\n                        column=reference_column,\n                        value=getattr(result_items[0], reference_column),\n                    )\n                    if result_items\n                    else None\n                ),\n                end_cursor=(\n                    CursorReference(\n                        column=reference_column,\n                        value=getattr(result_items[-1], reference_column),\n                    )\n                    if result_items\n                    else None\n                ),\n            ),\n        )\n\n    @staticmethod\n    def _build_after_cursor_result(\n        result_items: List[MODEL],\n        total_items_count: int,\n        items_per_page: int,\n        cursor_reference: CursorReference,\n    ) -&gt; CursorPaginatedResult:\n        index = 0\n        reference_column = cursor_reference.column\n        first_found_cursor_value = getattr(result_items[index], reference_column)\n        if not isinstance(first_found_cursor_value, type(cursor_reference.value)):\n            raise TypeError(\n                \"Values from CursorReference and results must be of the same type\"\n            )\n        has_previous_page = first_found_cursor_value &lt;= cursor_reference.value\n        if has_previous_page:\n            result_items.pop(index)\n        has_next_page = len(result_items) &gt; items_per_page\n        if has_next_page:\n            result_items = result_items[0:items_per_page]\n\n        return CursorPaginatedResult(\n            items=result_items,\n            page_info=CursorPageInfo(\n                items_per_page=items_per_page,\n                total_items=total_items_count,\n                has_previous_page=has_previous_page,\n                has_next_page=has_next_page,\n                start_cursor=(\n                    CursorReference(\n                        column=reference_column,\n                        value=getattr(result_items[0], reference_column),\n                    )\n                    if result_items\n                    else None\n                ),\n                end_cursor=(\n                    CursorReference(\n                        column=reference_column,\n                        value=getattr(result_items[-1], reference_column),\n                    )\n                    if result_items\n                    else None\n                ),\n            ),\n        )\n</code></pre>"},{"location":"API-Reference/_repository/result_presenters/#sqlalchemy_bind_manager._repository.result_presenters.CursorPaginatedResultPresenter.build_result","title":"<code>build_result(result_items, total_items_count, items_per_page, cursor_reference, is_before_cursor)</code>  <code>classmethod</code>","text":"<p>Produces a structured paginated result identifying previous/next pages and slicing results accordingly.</p> PARAMETER  DESCRIPTION <code>result_items</code> <p> TYPE: <code>List[MODEL]</code> </p> <code>total_items_count</code> <p> TYPE: <code>int</code> </p> <code>items_per_page</code> <p> TYPE: <code>int</code> </p> <code>cursor_reference</code> <p> TYPE: <code>Union[CursorReference, None]</code> </p> <code>is_before_cursor</code> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>CursorPaginatedResult</code> Source code in <code>sqlalchemy_bind_manager/_repository/result_presenters.py</code> <pre><code>@classmethod\ndef build_result(\n    cls,\n    result_items: List[MODEL],\n    total_items_count: int,\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None],\n    is_before_cursor: bool,\n) -&gt; CursorPaginatedResult:\n    \"\"\"\n    Produces a structured paginated result identifying previous/next pages\n    and slicing results accordingly.\n\n    :param result_items:\n    :param total_items_count:\n    :param items_per_page:\n    :param cursor_reference:\n    :param is_before_cursor:\n    :return:\n    \"\"\"\n    if not result_items:\n        return cls._build_empty_items_result(total_items_count, items_per_page)\n\n    if not cursor_reference:\n        return cls._build_no_cursor_result(\n            result_items, total_items_count, items_per_page\n        )\n\n    if is_before_cursor:\n        return cls._build_before_cursor_result(\n            result_items, total_items_count, items_per_page, cursor_reference\n        )\n\n    return cls._build_after_cursor_result(\n        result_items, total_items_count, items_per_page, cursor_reference\n    )\n</code></pre>"},{"location":"API-Reference/_repository/sync/","title":"Sync","text":""},{"location":"API-Reference/_unit_of_work/","title":"Index","text":""},{"location":"manager/alembic/","title":"Alembic integration","text":""},{"location":"manager/alembic/#using-alembic-with-sqlalchemy-bind-manager","title":"Using Alembic with SQLAlchemy bind manager","text":"<p>Alembic is a database migration tool widely used with SQLAlchemy.</p> <p>While the installation and configuration of Alembic is not in the scope of this package, <code>SQLAlchemyBindManager</code> class provides the method <code>get_bind_mappers_metadata()</code> for an easier integration with Alembic when using multiple binds. It will return each bind metadata organised in a dictionary, using the bind names as keys.</p> <p>Alembic provides templates for synchronous engines and for asynchronous engines, but there is no template supporting both at the same time.</p> <p>You can find an example Alembic configuration that works with synchronous and asynchronous engines at the same time, using the <code>SQLAlchemyBindManager</code> helper method, based on the following directory structure:</p> <pre><code>\u251c\u2500\u2500 alembic\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u2514\u2500\u2500 alembic.ini\n</code></pre>"},{"location":"manager/alembic/#alembicini","title":"alembic.ini","text":"alembic.ini <pre><code># a multi-database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file\n# for all available tokens\nfile_template = %%(year)d-%%(month).2d-%%(day).2d-%%(hour).2d%%(minute).2d%%(second).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to alembic/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"version_path_separator\" below.\n# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses os.pathsep.\n# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os  # Use os.pathsep. Default configuration used for new projects.\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# We inject db names and config using env.py in alembic directory\n#databases = engine1, engine2\n\n#[engine1]\n#sqlalchemy.url = driver://user:pass@localhost/dbname\n\n#[engine2]\n#sqlalchemy.url = driver://user:pass@localhost/dbname2\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n</code></pre>"},{"location":"manager/alembic/#envpy","title":"env.py","text":"env.py <pre><code>import logging\nimport os\nfrom asyncio import get_event_loop\n\nfrom alembic import context\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.asyncio import AsyncEngine\n\nfrom sqlalchemy_bind_manager import SQLAlchemyAsyncConfig, SQLAlchemyBindManager\n\n################################################################\n## Note: The bind_config, sa_manager and models are normally  ##\n## implemented in an application. This is only an example!    ##\n################################################################\nbind_config = {\n    \"default\": SQLAlchemyAsyncConfig(\n        engine_url=f\"sqlite+aiosqlite:///{os.path.dirname(os.path.abspath(__file__))}/sqlite.db\",\n        engine_options=dict(\n            connect_args={\n                \"check_same_thread\": False,\n            },\n            echo=False,\n            future=True,\n        ),\n    ),\n}\n\nsa_manager = SQLAlchemyBindManager(config=bind_config)\n\nclass BookModel(sa_manager.get_bind().declarative_base):\n    id = Column(Integer)\n    title = Column(String)\n################################################################\n## Note: The bind_config, sa_manager and models are normally  ##\n## implemented in an application. This is only an example!    ##\n################################################################\n\n\nUSE_TWOPHASE = False\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nlogger = logging.getLogger(\"alembic.env\")\ntarget_metadata = sa_manager.get_bind_mappers_metadata()\ndb_names = target_metadata.keys()\nconfig.set_main_option(\"databases\", \",\".join(db_names))\n\n\ndef run_migrations_offline() -&gt; None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    # for the --sql use case, run migrations for each URL into\n    # individual files.\n\n    engines = {}\n    for name in db_names:\n        engines[name] = {}\n        engines[name][\"url\"] = sa_manager.get_bind(name).engine.url\n\n    for name, rec in engines.items():\n        logger.info(f\"Migrating database {name}\")\n        file_ = f\"{name}.sql\"\n        logger.info(f\"Writing output to {file_}\")\n        with open(file_, \"w\") as buffer:\n            context.configure(\n                url=rec[\"url\"],\n                output_buffer=buffer,\n                target_metadata=target_metadata.get(name),\n                literal_binds=True,\n                dialect_opts={\"paramstyle\": \"named\"},\n            )\n            with context.begin_transaction():\n                context.run_migrations(engine_name=name)\n\n\ndef do_run_migration(conn, name):\n    context.configure(\n        connection=conn,\n        upgrade_token=f\"{name}_upgrades\",\n        downgrade_token=f\"{name}_downgrades\",\n        target_metadata=target_metadata.get(name),\n    )\n    context.run_migrations(engine_name=name)\n\n\nasync def run_migrations_online() -&gt; None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n\n    # for the direct-to-DB use case, start a transaction on all\n    # engines, then run all migrations, then commit all transactions.\n\n    engines = {}\n    for name in db_names:\n        engines[name] = {}\n        engines[name][\"engine\"] = sa_manager.get_bind(name).engine\n\n    for name, rec in engines.items():\n        engine = rec[\"engine\"]\n        if isinstance(engine, AsyncEngine):\n            rec[\"connection\"] = conn = await engine.connect()\n\n            if USE_TWOPHASE:\n                rec[\"transaction\"] = await conn.begin_twophase()\n            else:\n                rec[\"transaction\"] = await conn.begin()\n        else:\n            rec[\"connection\"] = conn = engine.connect()\n\n            if USE_TWOPHASE:\n                rec[\"transaction\"] = conn.begin_twophase()\n            else:\n                rec[\"transaction\"] = conn.begin()\n\n    try:\n        for name, rec in engines.items():\n            logger.info(f\"Migrating database {name}\")\n            if isinstance(rec[\"engine\"], AsyncEngine):\n\n                def migration_callable(*args, **kwargs):\n                    return do_run_migration(*args, name=name, **kwargs)\n\n                await rec[\"connection\"].run_sync(migration_callable)\n            else:\n                do_run_migration(name, rec)\n\n        if USE_TWOPHASE:\n            for rec in engines.values():\n                if isinstance(rec[\"engine\"], AsyncEngine):\n                    await rec[\"transaction\"].prepare()\n                else:\n                    rec[\"transaction\"].prepare()\n\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"transaction\"].commit()\n            else:\n                rec[\"transaction\"].commit()\n    except:\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"transaction\"].rollback()\n            else:\n                rec[\"transaction\"].rollback()\n        raise\n    finally:\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"connection\"].close()\n            else:\n                rec[\"connection\"].close()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    loop = get_event_loop()\n    if loop.is_running():\n        loop.create_task(run_migrations_online())\n    else:\n        loop.run_until_complete(run_migrations_online())\n</code></pre>"},{"location":"manager/alembic/#scriptpymako","title":"script.py.mako","text":"script.py.mako <pre><code>&lt;%!\nimport re\n\n%&gt;\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n${imports if imports else \"\"}\n\n# revision identifiers, used by Alembic.\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade(engine_name: str) -&gt; None:\n    globals()[f\"upgrade_{engine_name}\"]()\n\n\ndef downgrade(engine_name: str) -&gt; None:\n    globals()[f\"downgrade_{engine_name}\"]()\n\n&lt;%\n    db_names = config.get_main_option(\"databases\")\n%&gt;\n\n## generate an \"upgrade_&lt;xyz&gt;() / downgrade_&lt;xyz&gt;()\" function\n## for each database name in the ini file.\n\n% for db_name in re.split(r',\\s*', db_names):\n\ndef upgrade_${db_name}() -&gt; None:\n    ${context.get(f\"{db_name}_upgrades\", \"pass\")}\n\n\ndef downgrade_${db_name}() -&gt; None:\n    ${context.get(f\"{db_name}_downgrades\", \"pass\")}\n\n% endfor\n</code></pre>"},{"location":"manager/config/","title":"Configuration","text":""},{"location":"manager/config/#single-database-configuration","title":"Single database configuration","text":"<p>You can initialise the manager providing an instance of <code>SQLAlchemyConfig</code></p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = SQLAlchemyConfig(\n    engine_url=\"sqlite:///./sqlite.db\",\n    engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n    session_options=dict(expire_on_commit=False),\n)\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>The <code>engine_url</code> and <code>engine_options</code> dictionaries accept the same parameters as SQLAlchemy create_engine()</p> <p>The <code>session_options</code> dictionary accepts the same parameters as SQLALchemy sessionmaker()</p> <p>Once the bind manager is initialised we can retrieve and use the SQLAlchemyBind using the method <code>get_bind()</code></p> <p>The <code>SQLAlchemyBind</code> class has the following attributes:</p> <ul> <li><code>engine</code>: The initialised SQLALchemy <code>Engine</code></li> <li><code>declarative_base</code>: A base class that can be used to create declarative models</li> <li><code>registry_mapper</code>: The <code>registry</code> associated with the <code>engine</code>. It can be used with Alembic or to setup imperative mapping</li> <li><code>session_class</code>: The class built by sessionmaker(), either <code>Session</code> or <code>AsyncSession</code></li> </ul> <p>The <code>SQLAlchemyBindManager</code> provides some helper methods to quickly access some of the bind properties without using the <code>SQLAlchemyBind</code>:</p> <ul> <li><code>get_session</code>: returns a Session object</li> <li><code>get_mapper</code>: returns the mapper associated with the bind</li> </ul>"},{"location":"manager/config/#multiple-databases-configuration","title":"Multiple databases configuration","text":"<p><code>SQLAlchemyBindManager</code> accepts also multiple databases configuration, provided as a dictionary. The dictionary keys are used as a reference name for each bind.</p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = {\n    \"default\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./sqlite.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n    \"secondary\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./secondary.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n}\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>All the <code>SQLAlchemyBindManager</code> helper methods accept the <code>bind_name</code> optional parameter:</p> <ul> <li><code>get_session(bind_name=\"default\")</code></li> <li><code>get_mapper(bind_name=\"default\")</code></li> </ul>"},{"location":"manager/config/#asynchronous-database-engines","title":"Asynchronous database engines","text":"<p>Is it possible to supply configurations for asyncio supported engines using <code>SQLAlchemyAsyncConfig</code> objects.</p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyAsyncConfig, SQLAlchemyBindManager\n\nconfig = SQLAlchemyAsyncConfig(\n    engine_url=\"postgresql+asyncpg://scott:tiger@localhost/test\",\n)\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>This will make sure we initialise a <code>SQLAlchemyAsyncBind</code> object, containing <code>AsyncEngine</code> and <code>AsyncSession</code>.</p> <p>The interfaces are exactly the same, however you'll need to <code>await</code> the relevant functions in SQLAlchemy. E.g.:</p> <pre><code>async with sa_manager.get_session() as session:\n    session.add(o)\n    await session.commit()\n</code></pre> <p>Note that async implementation has several differences from the sync one, make sure to check SQLAlchemy asyncio documentation</p>"},{"location":"manager/models/","title":"Models setup","text":""},{"location":"manager/models/#models-configuration","title":"Models configuration","text":"<p>Creating models is exactly the same as SQLAlchemy documentation. </p> <p>Using declarative approach:</p> <pre><code>from sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy import String\n\nbind = sa_manager.get_bind()\n\nclass MyModel(bind.declarative_base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n</code></pre> <p>Or using the imperative approach:</p> <pre><code>from dataclasses import dataclass\nfrom sqlalchemy import Integer, String, Table, Column\n\n@dataclass\nclass MyModel:\n    id: int\n    name: str\n\nbind = sa_manager.get_bind()\n\nimperative_table = Table(\n    \"imperative\",\n    bind.registry_mapper.metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String, primary_key=True),\n)\n\nbind.registry_mapper.map_imperatively(MyModel, imperative_table)\n\n# or using the get_mapper() helper method\nsa_manager.get_mapper().map_imperatively(MyModel, imperative_table)\n</code></pre>"},{"location":"manager/session/","title":"Session usage","text":"<p>Using the session is the same as standard SQLAlchemy. The recommended approach is using the <code>get_session()</code> context manager, so you don't need to manage the session life cycle.</p> <pre><code># Persist an object\no = ImperativeModel()\no.name = \"John\"\nwith sa_manager.get_session() as session:\n    session.add(o)\n    session.commit()\n\n# We can also get the `session_class` property of the bind,\n# but this is not recommended.\nwith sa_manager.get_bind().session_class()() as session:\n    session.add(o)\n    session.commit()\n</code></pre>"},{"location":"manager/session/#note-on-multithreaded-applications","title":"Note on multithreaded applications","text":"<p>Global variables are shared between different threads in python. If your application uses multiple threads, like spawning a thread per request, then you should not store an initialised session in a global variable, otherwise the state of your models will be shared among the threads and produce undesired changes in the database.</p> <p>This is not thread safe:</p> <p>db.py (a module to have an easy to use session)</p> <pre><code>session = sa_manager.get_session()\n</code></pre> <p>some_other_module.py (a module to have an easy-to=use session)</p> <pre><code>from db import session\n\nsession.add(model)\nsession.commit()\n</code></pre> <p>This instead would be thread safe:</p> <p>some_other_module.py (a module to have an easy-to=use session)</p> <pre><code>def do_something():\n    session = sa_manager.get_session()\n    session.add(model)\n    session.commit()\n    session.close()\n\ndo_something()\n</code></pre> <p>The <code>do_something</code> function can be also in another method, as long as the <code>session</code> variable has no global scope it will be safe.</p> <p>Using the <code>get_session()</code> context manager is much easier</p> <p>If you truly need to have a long-lived session in a variable with global scope, you'll need to use a scoped session like this:</p> <pre><code>from sqlalchemy.orm import scoped_session\n\nsession = scoped_session(sa_manager.get_bind().session_class())\n</code></pre> <p>Handling the life cycle of scoped sessions is not supported by this documentations. Please refer to SQLAlchemy documentation about this.</p>"},{"location":"repository/uow/","title":"Unit of work","text":""},{"location":"repository/uow/#use-the-unit-of-work-to-share-a-session-among-multiple-repositories","title":"Use the Unit Of Work to share a session among multiple repositories","text":"<p>It is possible we need to run several operations in a single database get_session. While a single repository provide by itself an isolated session for single operations, we have to use a different approach for multiple operations.</p> <p>We can use the <code>UnitOfWork</code> or the <code>AsyncUnitOfWork</code> class to provide a shared session to be used for repository operations.</p> <pre><code>class MyRepo(SQLAlchemyRepository):\n    _model = MyModel\n\nbind = sa_manager.get_bind()\nuow = UnitOfWork(bind)\nuow.register_repository(\"repo_a\", MyRepo)\n# args and kwargs are forwarded so we can also use directly `SQLAlchemyRepository` class\nuow.register_repository(\"repo_b\", SQLAlchemyRepository, MyOtherModel)\n\nwith uow.transaction():\n    uow.repository(\"repo_a\").save(some_model)\n    uow.repository(\"repo_b\").save(some_other_model)\n\n# Optionally disable the commit/rollback handling\nwith uow.transaction(read_only=True):\n    model1 = uow.repository(\"repo_a\").get(1)\n    model2 = uow.repository(\"repo_b\").get(2)\n</code></pre> <p>The unit of work implementation is still experimental.</p> <p>There are some limitations in the current implementation that could radically change the implementation:</p> <ul> <li>Distributed transactions are not yet supported. </li> <li>The direct use of <code>SQLAlchemyRepository</code> and <code>SQLAlchemyAsyncRepository</code> classes is not yet supported.</li> </ul> <p>Both the UnitOfWork classes create an internal <code>scoped_session</code> or <code>async_scoped_session</code>, behaving in the same way at the repositories do. This provides the freedom to tune the session lifecycle based on our application requirements (e.g. one unit of work per http request, per domain, etc.)</p>"},{"location":"repository/usage/","title":"Repository usage","text":""},{"location":"repository/usage/#repository-unit-of-work","title":"Repository / Unit of work","text":"<p>The <code>SQLAlchemyRepository</code> and <code>SQLAlchemyAsyncRepository</code> class can be used directly or by extending them.</p> <pre><code>from sqlalchemy_bind_manager.repository import SQLAlchemyRepository\n\n\nclass MyModel(declarative_base):\n    pass\n\n# Direct usage\nrepo_instance = SQLAlchemyRepository(\n    sa_manager.get_bind(),\n    model_class=MyModel\n)\n\n# Child class usage (when you need to implement custom repository methods)\nclass ModelRepository(SQLAlchemyRepository[MyModel]):\n    _model = MyModel\n\n    def _some_custom_method_implemented(self):\n        ...\n\nrepo_instance_2 = ModelRepository(sa_manager.get_bind())\n</code></pre> <p>The classes provide some common use methods:</p> <ul> <li><code>get</code>: Retrieve a model by identifier</li> <li><code>save</code>: Persist a model</li> <li><code>save_many</code>: Persist multiple models in a single transaction</li> <li><code>delete</code>: Delete a model</li> <li><code>find</code>: Search for a list of models (basically an adapter for SELECT queries)</li> <li><code>paginated_find</code>: Search for a list of models, with pagination support</li> <li><code>cursor_paginated_find</code>: Search for a list of models, with cursor based pagination support</li> </ul> Typing and Protocols <p>The repository classes are fully typed (as the rest of this package), but protocols classes are provided as addition to allow more decoupled type checking and inversion of control patterns such as dependency injection.</p> <pre><code>from sqlalchemy_bind_manager.protocols import SQLAlchemyRepositoryInterface, SQLAlchemyAsyncRepositoryInterface\n\ndef some_function(repository: SQLAlchemyRepositoryInterface[MyModel]):\n    model = repository.get(123)\n    ...\n\nasync def some_async_function(repository: SQLAlchemyAsyncRepositoryInterface[MyModel]):\n    model = await repository.get(123)\n    ...\n</code></pre> <p>Both repository and related protocols are Generic, accepting the model class as argument.</p>"},{"location":"repository/usage/#maximum-query-limit","title":"Maximum query limit","text":"<p>Repositories have a maximum limit for paginated queries defaulting to 50 to avoid pulling pages with too many items by mistake. You can override this limit by overriding the <code>_max_query_limit</code> repository property. E.g.:</p> <pre><code>class ModelRepository(SQLAlchemyRepository[MyModel]):\n    _model = MyModel\n    _max_query_limit: int = 2000\n</code></pre> <p>The query limit does not apply to the non paginated <code>find()</code></p>"},{"location":"repository/usage/#session-lifecycle-in-repositories","title":"Session lifecycle in repositories","text":"<p>SQLAlchemy documentation recommends we create <code>Session</code> object at the beginning of a logical operation where database access is potentially anticipated.</p> <p>Doing this too soon might cause unexpected effects, like unexpected updates being committed, if the initialised session is shared among different repositories.</p> <p>A <code>Repository</code> represents a generic interface to persist data object to a storage, not necessarily using SQLAlchemy. It makes sense that the lifecycle of a <code>Session</code> follows the one of the Repository (The assumption is: if we create a Repository, we're going to do a DB operation, otherwise we wouldn't need one).</p> <p>Each Repository instance create an internal scoped session. The session gets automatically closed when the Repository instance is not referenced by any variable (and the garbage collector cleans it up)</p> <p>In this way we ensure the <code>Session</code> we use is isolated, and the same for all the operations we do with the same Repository. </p> <p>This approach has a consequence: We can't use SQLAlchemy lazy loading, so we'll need to make sure relationship are always loaded eagerly, using either approach: * Setup your model/table relationships to always use always eager loading * Implement ad-hoc methods to deal with relationships as necessary</p> <p>Note that <code>AsyncSession</code> has the same limitation on lazy loading, even when keeping the session opened, so it makes sense that the two Repository implementations behave consistently.</p> Lazy loading using <code>AsyncAttrs</code> <p>SQLAlchemy has recently added the <code>AsyncAttrs</code> model class mixin to allow lazy loading model attributes  with <code>AsyncSession</code>, however having to <code>await</code> a model property introduce a coupling between the application logic and the storage layer.</p> <p>This would mean the application logic has to know about the storage layer and make a distinction between sync and async models. This doesn't feel right, at least for now, therefore it's not enabled by default.</p> <p>If you want to attempt lazy loading refer to SQLAlchemy documentation</p>"}]}