{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLAlchemy bind manager","text":"<p>This package provides an easy way to configure and use SQLAlchemy engines and sessions without depending on frameworks.</p> <p>It is composed by two main components:</p> <ul> <li>A manager class for SQLAlchemy engine and session configuration</li> <li>A repository/unit-of-work pattern implementation for model retrieval and persistence</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install sqlalchemy-bind-manager\n</code></pre>"},{"location":"#components-maturity","title":"Components maturity","text":"<ul> <li> SQLAlchemy manager: Implementation is mostly finalised, needs testing in production.</li> <li> Repository: Implementation is mostly finalised, needs testing in production.</li> <li> Unit of work: The implementation is working but limited to repositories using the same engine. Distributed transactions across different engines are not yet supported.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>The complete documentation can be found here</p>"},{"location":"#sqlalchemy-manager","title":"SQLAlchemy manager","text":"<p>Initialise the manager providing an instance of <code>SQLAlchemyConfig</code></p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = SQLAlchemyConfig(\n    engine_url=\"sqlite:///./sqlite.db\",\n    engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n    session_options=dict(expire_on_commit=False),\n)\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>\ud83d\udea8 NOTE: Using global variables is not thread-safe, please read the Documentation if your application uses multi-threading.</p> <p>The <code>engine_url</code> and <code>engine_options</code> dictionaries accept the same parameters as SQLAlchemy create_engine()</p> <p>The <code>session_options</code> dictionary accepts the same parameters as SQLALchemy sessionmaker()</p> <p>The <code>SQLAlchemyBindManager</code> provides some helper methods for common operations:</p> <ul> <li><code>get_bind</code>: returns a <code>SQLAlchemyBind</code> or <code>SQLAlchemyAsyncBind</code> object</li> <li><code>get_session</code>: returns a <code>Session</code> object, which works also as a context manager</li> <li><code>get_mapper</code>: returns the mapper associated with the bind</li> </ul> <p>Example:</p> <pre><code>bind = sa_manager.get_bind()\n\n\nclass MyModel(bind.declarative_base):\n    pass\n\n\n# Persist an object\no = MyModel()\no.name = \"John\"\nwith sa_manager.get_session() as session:\n    session.add(o)\n    session.commit()\n</code></pre> <p>Imperative model declaration is also supported.</p>"},{"location":"#multiple-database-binds","title":"Multiple database binds","text":"<p><code>SQLAlchemyBindManager</code> accepts also multiple databases configuration, provided as a dictionary. The dictionary keys are used as a reference name for each bind.</p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = {\n    \"default\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./sqlite.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n    \"secondary\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./secondary.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n}\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>All the <code>SQLAlchemyBindManager</code> helper methods accept the <code>bind_name</code> optional parameter:</p> <ul> <li><code>get_bind(bind_name=\"default\")</code>: returns a <code>SQLAlchemyBind</code> or <code>SQLAlchemyAsyncBind</code> object</li> <li><code>get_session(bind_name=\"default\")</code>: returns a <code>Session</code> or <code>AsyncSession</code> object, which works also as a context manager</li> <li><code>get_mapper(bind_name=\"default\")</code>: returns the mapper associated with the bind</li> </ul>"},{"location":"#asynchronous-database-binds","title":"Asynchronous database binds","text":"<p>Is it possible to supply configurations for asyncio supported engines.</p> <pre><code>config = SQLAlchemyAsyncConfig(\n    engine_url=\"postgresql+asyncpg://scott:tiger@localhost/test\",\n)\n</code></pre> <p>This will make sure we have an <code>AsyncEngine</code> and an <code>AsyncSession</code> are initialised, as an asynchronous context manager.</p> <pre><code>async with sa_manager.get_session() as session:\n    session.add(o)\n    await session.commit()\n</code></pre> <p>Note that async implementation has several differences from the sync one, make sure to check SQLAlchemy asyncio documentation</p>"},{"location":"#repository-unit-of-work","title":"Repository / Unit of work","text":"<p>The <code>SQLAlchemyRepository</code> and <code>SQLAlchemyAsyncRepository</code> class can be used directly or by extending them.</p> <pre><code>from sqlalchemy_bind_manager.repository import SQLAlchemyRepository\n\n\nclass MyModel(declarative_base):\n    pass\n\n# Direct usage\nrepo_instance = SQLAlchemyRepository(sqlalchemy_bind_manager.get_bind(), model_class=MyModel)\n\nclass ModelRepository(SQLAlchemyRepository[MyModel]):\n    _model = MyModel\n\n    def _some_custom_method_implemented(self):\n        ...\n\n# Extended class usage\nextended_repo_instance = ModelRepository(sqlalchemy_bind_manager.get_bind())\n</code></pre> <p>The repository classes provides methods for  common use case:</p> <ul> <li><code>get</code>: Retrieve a model by primary key</li> <li><code>save</code>: Persist a model</li> <li><code>save_many</code>: Persist multiple models in a single transaction</li> <li><code>delete</code>: Delete a model</li> <li><code>find</code>: Search for a list of models (basically an adapter for SELECT queries)</li> <li><code>paginated_find</code>: Search for a list of models, with pagination support</li> <li><code>cursor_paginated_find</code>: Search for a list of models, with cursor based pagination support</li> </ul>"},{"location":"#use-the-unit-of-work-to-share-a-session-among-multiple-repositories","title":"Use the Unit Of Work to share a session among multiple repositories","text":"<p>It is possible we need to run several operations in a single database transaction. While a single repository provide by itself an isolated session for single operations, we have to use a different approach for multiple operations.</p> <p>We can use the <code>UnitOfWork</code> or the <code>AsyncUnitOfWork</code> class to provide a shared session to be used for repository operations, assumed the same bind is used for all the repositories.</p> <pre><code>class MyRepo(SQLAlchemyRepository):\n    _model = MyModel\n\nbind = sa_manager.get_bind()\nuow = UnitOfWork(bind)\nuow.register_repository(\"repo_a\", MyRepo)\nuow.register_repository(\"repo_b\", SQLAlchemyRepository, MyOtherModel)\n\nwith uow.transaction():\n    uow.repository(\"repo_a\").save(some_model)\n    uow.repository(\"repo_b\").save(some_other_model)\n</code></pre>"},{"location":"lifecycle/","title":"Components life cycle","text":""},{"location":"lifecycle/#when-should-you-create-each-component","title":"When should you create each component?","text":""},{"location":"lifecycle/#bind-manager","title":"Bind manager","text":"<p>The <code>SQLAlchemyBindManager</code> object holds all the SQLAlchemy Engines, which are supposed to be global objects, therefore it should be created on application startup and be globally accessible.</p> <p>From SQLAlchemy documentation:</p> <p>The Engine is intended to normally be a permanent fixture established up-front and maintained throughout the lifespan of an application.</p>"},{"location":"lifecycle/#repositories","title":"Repositories","text":"<p>SQLAlchemy documentation recommends we create <code>Session</code> object at the beginning of a logical operation where database access is potentially anticipated.</p> <p>The repository keeps a <code>Session</code> object scoped to its lifecycle to avoid unnecessary queries, and executes a transaction for each operation to maintain isolation. This means you can create a repository object almost whenever you want, as long as you don't run parallel operations.</p> <p>The repository is safe in multithreaded applications and in concurrent asyncio tasks, this means that potentially you can save it in a global variable, and it will have a different <code>Session</code> in each thread or asyncio task.</p> <p>Even if the repository can be used with concurrency or parallelism, remember SQLAlchemy models belong to a single <code>Session</code>, so sharing the same models in multiple threads or asyncio tasks will cause problems.</p> <p>What you can do is:</p> <ul> <li>Save the repositories in global variables and start a thread / asyncio task to handle   a scoped request (e.g. one thread per HTTP request)</li> </ul> <p>What you should not do is:</p> <ul> <li>Get a list of models</li> <li>Save the models using <code>save()</code> in parallel threads / tasks (each task will have a different session)</li> </ul> <p>Remember: Concurrent writes to the db can cause undesired scenarios like locks and deadlocks!</p> <p>The recommendation is to try to use a single repository instance, where possible.</p> <p>For example a strategy similar to this would be optimal, if possible:</p> <ul> <li>Create repositories</li> <li>Retrieve all the models you need</li> <li>Do the changes you need, as per business logic, eventually using multiple threads / tasks</li> <li>Save all the changed models as needed</li> </ul>"},{"location":"lifecycle/#unit-of-work","title":"Unit of work","text":"<p>The Unit of Work session management follows the same exact rules as the repository, therefore you should approach the creation af a <code>UnitOfWork</code> object in the same way.</p>"},{"location":"api_reference/bind_manager/","title":"Bind manager","text":""},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager","title":"sqlalchemy_bind_manager","text":""},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager","title":"sqlalchemy_bind_manager.SQLAlchemyBindManager","text":"Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>class SQLAlchemyBindManager:\n    __binds: MutableMapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]\n\n    def __init__(\n        self,\n        config: Union[\n            Mapping[str, SQLAlchemyConfig],\n            SQLAlchemyConfig,\n        ],\n    ) -&gt; None:\n        self.__binds = {}\n        if isinstance(config, Mapping):\n            for name, conf in config.items():\n                self.__init_bind(name, conf)\n        else:\n            self.__init_bind(DEFAULT_BIND_NAME, config)\n\n    def __init_bind(self, name: str, config: SQLAlchemyConfig):\n        if not isinstance(config, SQLAlchemyConfig):\n            raise InvalidConfigError(\n                f\"Config for bind `{name}` is not a SQLAlchemyConfig object\"\n            )\n\n        engine_options: dict = config.engine_options or {}\n        engine_options.setdefault(\"echo\", False)\n        engine_options.setdefault(\"future\", True)\n\n        session_options: dict = config.session_options or {}\n        session_options.setdefault(\"expire_on_commit\", False)\n        session_options.setdefault(\"autobegin\", False)\n\n        if config.async_engine:\n            self.__binds[name] = self.__build_async_bind(\n                engine_url=config.engine_url,\n                engine_options=engine_options,\n                session_options=session_options,\n            )\n        else:\n            self.__binds[name] = self.__build_sync_bind(\n                engine_url=config.engine_url,\n                engine_options=engine_options,\n                session_options=session_options,\n            )\n\n    def __build_sync_bind(\n        self,\n        engine_url: str,\n        engine_options: dict,\n        session_options: dict,\n    ) -&gt; SQLAlchemyBind:\n        registry_mapper = registry()\n        engine = create_engine(engine_url, **engine_options)\n        return SQLAlchemyBind(\n            engine=engine,\n            registry_mapper=registry_mapper,\n            session_class=sessionmaker(\n                bind=engine,\n                class_=Session,\n                **session_options,\n            ),\n            declarative_base=registry_mapper.generate_base(),\n        )\n\n    def __build_async_bind(\n        self,\n        engine_url: str,\n        engine_options: dict,\n        session_options: dict,\n    ) -&gt; SQLAlchemyAsyncBind:\n        registry_mapper = registry()\n        engine = create_async_engine(engine_url, **engine_options)\n        return SQLAlchemyAsyncBind(\n            engine=engine,\n            registry_mapper=registry_mapper,\n            session_class=async_sessionmaker(\n                bind=engine,\n                **session_options,\n            ),\n            declarative_base=registry_mapper.generate_base(),\n        )\n\n    def get_bind_mappers_metadata(self) -&gt; Mapping[str, MetaData]:\n        \"\"\"\n        Returns the registered mappers metadata in a format\n        that can be used in Alembic configuration\n\n        :returns: mappers metadata\n        \"\"\"\n        return {k: b.registry_mapper.metadata for k, b in self.__binds.items()}\n\n    def get_bind(\n        self, bind_name: str = DEFAULT_BIND_NAME\n    ) -&gt; Union[SQLAlchemyBind, SQLAlchemyAsyncBind]:\n        \"\"\"\n        Returns a bind object by name.\n\n        :param bind_name: A registered bind name\n        :return: a bind object\n        \"\"\"\n        try:\n            return self.__binds[bind_name]\n        except KeyError:\n            raise NotInitializedBindError(\"Bind not initialized\")\n\n    def get_binds(self) -&gt; Mapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]:\n        \"\"\"\n        Returns all the registered bind objects.\n\n        :returns: A mapping containing the registered binds\n        \"\"\"\n        return self.__binds\n\n    def get_mapper(self, bind_name: str = DEFAULT_BIND_NAME) -&gt; registry:\n        \"\"\"\n        Returns the registered SQLAlchemy registry_mapper for the given bind name\n\n        :param bind_name: A registered bind name\n        :return: the registered registry_mapper\n        \"\"\"\n        return self.get_bind(bind_name).registry_mapper\n\n    def get_session(\n        self, bind_name: str = DEFAULT_BIND_NAME\n    ) -&gt; Union[Session, AsyncSession]:\n        \"\"\"\n        Returns a SQLAlchemy Session object, ready to be used either\n        directly or as a context manager\n\n        :param bind_name: A registered bind name\n        :return: The SQLAlchemy Session object\n        \"\"\"\n        return self.get_bind(bind_name).session_class()\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager.get_bind_mappers_metadata","title":"get_bind_mappers_metadata","text":"<pre><code>get_bind_mappers_metadata() -&gt; Mapping[str, MetaData]\n</code></pre> <p>Returns the registered mappers metadata in a format that can be used in Alembic configuration</p> <p>Returns:</p> Type Description <code>Mapping[str, MetaData]</code> <p>mappers metadata</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_bind_mappers_metadata(self) -&gt; Mapping[str, MetaData]:\n    \"\"\"\n    Returns the registered mappers metadata in a format\n    that can be used in Alembic configuration\n\n    :returns: mappers metadata\n    \"\"\"\n    return {k: b.registry_mapper.metadata for k, b in self.__binds.items()}\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager.get_bind","title":"get_bind","text":"<pre><code>get_bind(\n    bind_name: str = DEFAULT_BIND_NAME,\n) -&gt; Union[SQLAlchemyBind, SQLAlchemyAsyncBind]\n</code></pre> <p>Returns a bind object by name.</p> <p>Parameters:</p> Name Type Description Default <code>bind_name</code> <code>str</code> <p>A registered bind name</p> <code>DEFAULT_BIND_NAME</code> <p>Returns:</p> Type Description <code>Union[SQLAlchemyBind, SQLAlchemyAsyncBind]</code> <p>a bind object</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_bind(\n    self, bind_name: str = DEFAULT_BIND_NAME\n) -&gt; Union[SQLAlchemyBind, SQLAlchemyAsyncBind]:\n    \"\"\"\n    Returns a bind object by name.\n\n    :param bind_name: A registered bind name\n    :return: a bind object\n    \"\"\"\n    try:\n        return self.__binds[bind_name]\n    except KeyError:\n        raise NotInitializedBindError(\"Bind not initialized\")\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager.get_binds","title":"get_binds","text":"<pre><code>get_binds() -&gt; Mapping[\n    str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]\n]\n</code></pre> <p>Returns all the registered bind objects.</p> <p>Returns:</p> Type Description <code>Mapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]</code> <p>A mapping containing the registered binds</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_binds(self) -&gt; Mapping[str, Union[SQLAlchemyBind, SQLAlchemyAsyncBind]]:\n    \"\"\"\n    Returns all the registered bind objects.\n\n    :returns: A mapping containing the registered binds\n    \"\"\"\n    return self.__binds\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager.get_mapper","title":"get_mapper","text":"<pre><code>get_mapper(bind_name: str = DEFAULT_BIND_NAME) -&gt; registry\n</code></pre> <p>Returns the registered SQLAlchemy registry_mapper for the given bind name</p> <p>Parameters:</p> Name Type Description Default <code>bind_name</code> <code>str</code> <p>A registered bind name</p> <code>DEFAULT_BIND_NAME</code> <p>Returns:</p> Type Description <code>registry</code> <p>the registered registry_mapper</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_mapper(self, bind_name: str = DEFAULT_BIND_NAME) -&gt; registry:\n    \"\"\"\n    Returns the registered SQLAlchemy registry_mapper for the given bind name\n\n    :param bind_name: A registered bind name\n    :return: the registered registry_mapper\n    \"\"\"\n    return self.get_bind(bind_name).registry_mapper\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyBindManager.get_session","title":"get_session","text":"<pre><code>get_session(\n    bind_name: str = DEFAULT_BIND_NAME,\n) -&gt; Union[Session, AsyncSession]\n</code></pre> <p>Returns a SQLAlchemy Session object, ready to be used either directly or as a context manager</p> <p>Parameters:</p> Name Type Description Default <code>bind_name</code> <code>str</code> <p>A registered bind name</p> <code>DEFAULT_BIND_NAME</code> <p>Returns:</p> Type Description <code>Union[Session, AsyncSession]</code> <p>The SQLAlchemy Session object</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>def get_session(\n    self, bind_name: str = DEFAULT_BIND_NAME\n) -&gt; Union[Session, AsyncSession]:\n    \"\"\"\n    Returns a SQLAlchemy Session object, ready to be used either\n    directly or as a context manager\n\n    :param bind_name: A registered bind name\n    :return: The SQLAlchemy Session object\n    \"\"\"\n    return self.get_bind(bind_name).session_class()\n</code></pre>"},{"location":"api_reference/bind_manager/#sqlalchemy_bind_manager.SQLAlchemyConfig","title":"sqlalchemy_bind_manager.SQLAlchemyConfig","text":"<p>Configuration for engines</p> Source code in <code>sqlalchemy_bind_manager/_bind_manager.py</code> <pre><code>class SQLAlchemyConfig(BaseModel):\n    \"\"\"\n    Configuration for engines\n    \"\"\"\n\n    engine_url: str\n    engine_options: Union[dict, None] = None\n    session_options: Union[dict, None] = None\n    async_engine: StrictBool = False\n</code></pre>"},{"location":"api_reference/exceptions/","title":"Exceptions","text":""},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions","title":"sqlalchemy_bind_manager.exceptions","text":""},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.NotInitializedBindError","title":"sqlalchemy_bind_manager.exceptions.NotInitializedBindError","text":"<p>Raised when a bind object does not exist (i.e. not yet initialized)</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class NotInitializedBindError(Exception):\n    \"\"\"\n    Raised when a bind object does not exist (i.e. not yet initialized)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.UnsupportedBindError","title":"sqlalchemy_bind_manager.exceptions.UnsupportedBindError","text":"<p>Raised when the internal session handler is given an unsupported bind object. Usually it happens when Async and Sync implementation are mixed up (i.e. initializing an <code>AsyncUnitOfWork</code> instance with a Sync bind)</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class UnsupportedBindError(Exception):\n    \"\"\"\n    Raised when the internal session handler is given an unsupported bind object.\n    Usually it happens when Async and Sync implementation are mixed up\n    (i.e. initializing an `AsyncUnitOfWork` instance with a Sync bind)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.InvalidConfigError","title":"sqlalchemy_bind_manager.exceptions.InvalidConfigError","text":"<p>Raised when a class is initialized with an invalid configuration and/or parameters.</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class InvalidConfigError(Exception):\n    \"\"\"\n    Raised when a class is initialized with an invalid configuration and/or parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.ModelNotFoundError","title":"sqlalchemy_bind_manager.exceptions.ModelNotFoundError","text":"<p>Raised when a Repository is not able to find a model using the provided primary key.</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class ModelNotFoundError(Exception):\n    \"\"\"\n    Raised when a Repository is not able to find a model using the provided primary key.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.InvalidModelError","title":"sqlalchemy_bind_manager.exceptions.InvalidModelError","text":"<p>Raised when an invalid model is passed to a Repository object or class.</p> <p>i.e.:</p> <ul> <li>Trying to instantiate a repository with a non SQLAlchemy model</li> <li>Trying to save a model belonging to another Repository class</li> </ul> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class InvalidModelError(Exception):\n    \"\"\"\n    Raised when an invalid model is passed to a Repository object or class.\n\n    i.e.:\n\n     * Trying to instantiate a repository with a non SQLAlchemy model\n     * Trying to save a model belonging to another Repository class\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.UnmappedPropertyError","title":"sqlalchemy_bind_manager.exceptions.UnmappedPropertyError","text":"<p>Raised when trying to execute queries using not mapped column names. (i.e. passing a non-existing column to <code>search_params</code> or <code>order_by</code> parameters when invoking <code>find()</code>)</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class UnmappedPropertyError(Exception):\n    \"\"\"\n    Raised when trying to execute queries using not mapped column names.\n    (i.e. passing a non-existing column to `search_params`\n    or `order_by` parameters when invoking `find()`)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/exceptions/#sqlalchemy_bind_manager.exceptions.RepositoryNotFoundError","title":"sqlalchemy_bind_manager.exceptions.RepositoryNotFoundError","text":"<p>Raised when trying to use a repository that has not been registered with the unit of work instance.</p> Source code in <code>sqlalchemy_bind_manager/exceptions.py</code> <pre><code>class RepositoryNotFoundError(Exception):\n    \"\"\"\n    Raised when trying to use a repository that has not been registered\n    with the unit of work instance.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/repository/","title":"Repository","text":""},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository","title":"sqlalchemy_bind_manager.repository","text":""},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository","title":"sqlalchemy_bind_manager.repository.SQLAlchemyRepository","text":"Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>class SQLAlchemyRepository(\n    Generic[MODEL],\n    BaseRepository[MODEL],\n):\n    _session_handler: SessionHandler\n    _external_session: Union[Session, None]\n\n    def __init__(\n        self,\n        bind: Union[SQLAlchemyBind, None] = None,\n        session: Union[Session, None] = None,\n        model_class: Union[Type[MODEL], None] = None,\n    ) -&gt; None:\n        super().__init__(model_class=model_class)\n        if not (bool(bind) ^ bool(session)):\n            raise InvalidConfigError(\n                \"Either `bind` or `session` have to be used, not both\"\n            )\n        self._external_session = session\n        if bind:\n            self._session_handler = SessionHandler(bind)\n\n    def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n        \"\"\"Get a model by primary key.\n\n        :param identifier: The primary key\n        :return: A model instance\n        :raises ModelNotFoundError: No model has been found using the primary key\n        \"\"\"\n        with self._get_session(commit=False) as session:\n            model = session.get(self._model, identifier)\n        if model is None:\n            raise ModelNotFoundError(\"No rows found for provided primary key.\")\n        return model\n\n    def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n        \"\"\"Get a list of models by primary keys.\n\n        :param identifiers: A list of primary keys\n        :return: A list of models\n        \"\"\"\n        stmt = select(self._model).where(\n            getattr(self._model, self._model_pk()).in_(identifiers)\n        )\n\n        with self._get_session(commit=False) as session:\n            return [x for x in session.execute(stmt).scalars()]\n\n    def save(self, instance: MODEL) -&gt; MODEL:\n        \"\"\"Persist a model.\n\n        :param instance: A mapped object instance to be persisted\n        :return: The model instance after being persisted\n        \"\"\"\n        self._fail_if_invalid_models([instance])\n        with self._get_session() as session:\n            session.add(instance)\n        return instance\n\n    def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n        \"\"\"Persist many models in a single database get_session.\n\n        :param instances: A list of mapped objects to be persisted\n        :return: The model instances after being persisted\n        \"\"\"\n        self._fail_if_invalid_models(instances)\n        with self._get_session() as session:\n            session.add_all(instances)\n        return instances\n\n    def delete(self, instance: MODEL) -&gt; None:\n        \"\"\"Deletes a model.\n\n        :param instance: The model instance\n        \"\"\"\n        self._fail_if_invalid_models([instance])\n        with self._get_session() as session:\n            session.delete(instance)\n\n    def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n        \"\"\"Deletes a collection of models in a single transaction.\n\n        :param instances: The model instances\n        \"\"\"\n        self._fail_if_invalid_models(instances)\n        with self._get_session() as session:\n            for model in instances:\n                session.delete(model)\n\n    def find(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[\n            None,\n            Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n        ] = None,\n    ) -&gt; List[MODEL]:\n        \"\"\"Find models using filters.\n\n        E.g.\n\n            # find all models with name = John\n            find(search_params={\"name\":\"John\"})\n\n            # find all models ordered by `name` column\n            find(order_by=[\"name\"])\n\n            # find all models with reversed order by `name` column\n            find(order_by=[(\"name\", \"desc\")])\n\n        :param search_params: A mapping containing equality filters\n        :param order_by:\n        :return: A collection of models\n        \"\"\"\n        stmt = self._find_query(search_params, order_by)\n\n        with self._get_session() as session:\n            result = session.execute(stmt)\n            return [x for x in result.scalars()]\n\n    def paginated_find(\n        self,\n        items_per_page: int,\n        page: int = 1,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[\n            None,\n            Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n        ] = None,\n    ) -&gt; PaginatedResult[MODEL]:\n        \"\"\"Find models using filters and limit/offset pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n\n            # find all models with name = John\n            paginated_find(search_params={\"name\":\"John\"})\n\n            # find first 50 models with name = John\n            paginated_find(50, search_params={\"name\":\"John\"})\n\n            # find 50 models with name = John, skipping 2 pages (100)\n            paginated_find(50, 3, search_params={\"name\":\"John\"})\n\n            # find all models ordered by `name` column\n            paginated_find(order_by=[\"name\"])\n\n            # find all models with reversed order by `name` column\n            paginated_find(order_by=[(\"name\", \"desc\")])\n\n        :param items_per_page: Number of models to retrieve\n        :param page: Page to retrieve\n        :param search_params: A mapping containing equality filters\n        :param order_by:\n        :return: A collection of models\n        \"\"\"\n        find_stmt = self._find_query(search_params, order_by)\n        paginated_stmt = self._paginate_query_by_page(find_stmt, page, items_per_page)\n\n        with self._get_session() as session:\n            total_items_count = (\n                session.execute(self._count_query(find_stmt)).scalar() or 0\n            )\n            result_items = [x for x in session.execute(paginated_stmt).scalars()]\n\n            return PaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                page=page,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n            )\n\n    def cursor_paginated_find(\n        self,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None] = None,\n        is_before_cursor: bool = False,\n        search_params: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; CursorPaginatedResult[MODEL]:\n        \"\"\"Find models using filters and cursor based pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n\n            # finds all models with name = John\n            cursor_paginated_find(search_params={\"name\":\"John\"})\n\n            # finds first 50 models with name = John\n            cursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n            # finds first 50 models after the one with \"id\" 123\n            cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n            # finds last 50 models before the one with \"id\" 123\n            cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n\n        :param items_per_page: Number of models to retrieve\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :param search_params: A mapping containing equality filters\n        :return: A collection of models\n        \"\"\"\n        find_stmt = self._find_query(search_params)\n\n        paginated_stmt = self._cursor_paginated_query(\n            find_stmt,\n            cursor_reference=cursor_reference,\n            is_before_cursor=is_before_cursor,\n            items_per_page=items_per_page,\n        )\n\n        with self._get_session() as session:\n            total_items_count = (\n                session.execute(self._count_query(find_stmt)).scalar() or 0\n            )\n            result_items = [x for x in session.execute(paginated_stmt).scalars()]\n\n            return CursorPaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n                cursor_reference=cursor_reference,\n                is_before_cursor=is_before_cursor,\n            )\n\n    @contextmanager\n    def _get_session(self, commit: bool = True) -&gt; Iterator[Session]:\n        if not self._external_session:\n            with self._session_handler.get_session(not commit) as _session:\n                yield _session\n        else:\n            yield self._external_session\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._is_mapped_class","title":"_is_mapped_class","text":"<pre><code>_is_mapped_class(class_: Type[MODEL]) -&gt; bool\n</code></pre> <p>Checks if the class is mapped in SQLAlchemy.</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>Type[MODEL]</code> <p>the model class</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the Type is mapped, False otherwise</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _is_mapped_class(self, class_: Type[MODEL]) -&gt; bool:\n    \"\"\"Checks if the class is mapped in SQLAlchemy.\n\n    :param class_: the model class\n    :return: True if the Type is mapped, False otherwise\n    :rtype: bool\n    \"\"\"\n    try:\n        class_mapper(class_)\n        return True\n    except UnmappedClassError:\n        return False\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._validate_mapped_property","title":"_validate_mapped_property","text":"<pre><code>_validate_mapped_property(property_name: str) -&gt; None\n</code></pre> <p>Checks if a property is mapped in the model class.</p> <p>Parameters:</p> Name Type Description Default <code>property_name</code> <code>str</code> <p>The name of the property to be evaluated.</p> required <p>Raises:</p> Type Description <code>UnmappedPropertyError</code> <p>When the property is not mapped.</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _validate_mapped_property(self, property_name: str) -&gt; None:\n    \"\"\"Checks if a property is mapped in the model class.\n\n    :param property_name: The name of the property to be evaluated.\n    :type property_name: str\n    :raises UnmappedPropertyError: When the property is not mapped.\n    \"\"\"\n    m: Mapper = class_mapper(self._model)\n    if property_name not in m.column_attrs:\n        raise UnmappedPropertyError(\n            f\"Property `{property_name}` is not mapped\"\n            f\" in the ORM for model `{self._model}`\"\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._filter_select","title":"_filter_select","text":"<pre><code>_filter_select(\n    stmt: Select, search_params: Mapping[str, Any]\n) -&gt; Select\n</code></pre> <p>Build the query filtering clauses from submitted parameters.</p> <p>E.g. _filter_select(stmt, name=\"John\") adds a <code>WHERE name = John</code> statement</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>search_params</code> <code>Mapping[str, Any]</code> <p>Any keyword argument to be used as equality filter</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _filter_select(self, stmt: Select, search_params: Mapping[str, Any]) -&gt; Select:\n    \"\"\"Build the query filtering clauses from submitted parameters.\n\n    E.g.\n    _filter_select(stmt, name=\"John\") adds a `WHERE name = John` statement\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param search_params: Any keyword argument to be used as equality filter\n    :type search_params: Mapping[str, Any]\n    :return: The filtered query\n    \"\"\"\n    # TODO: Add support for relationship eager load\n    for k, v in search_params.items():\n        \"\"\"\n        This acts as a TypeGuard but using TypeGuard typing would break\n        compatibility with python &lt; 3.10, for the moment we prefer to ignore\n        typing issues here\n        \"\"\"\n        self._validate_mapped_property(k)\n        stmt = stmt.where(getattr(self._model, k) == v)\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._filter_order_by","title":"_filter_order_by","text":"<pre><code>_filter_order_by(\n    stmt: Select,\n    order_by: Iterable[\n        Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n    ],\n) -&gt; Select\n</code></pre> <p>Build the query ordering clauses from submitted parameters.</p> <p>E.g. <code>_filter_order_by(stmt, ['name'])</code>     adds a <code>ORDER BY name</code> statement</p> <p><code>_filter_order_by(stmt, [('name', 'asc')])</code>     adds a <code>ORDER BY name ASC</code> statement</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>order_by</code> <code>Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]</code> <p>a list of columns, or tuples (column, direction)</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _filter_order_by(\n    self,\n    stmt: Select,\n    order_by: Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n) -&gt; Select:\n    \"\"\"Build the query ordering clauses from submitted parameters.\n\n    E.g.\n    `_filter_order_by(stmt, ['name'])`\n        adds a `ORDER BY name` statement\n\n    `_filter_order_by(stmt, [('name', 'asc')])`\n        adds a `ORDER BY name ASC` statement\n\n    :param stmt: a Select statement\n    :param order_by: a list of columns, or tuples (column, direction)\n    :return: The filtered query\n    \"\"\"\n    _partial_registry: Dict[Literal[\"asc\", \"desc\"], Callable] = {\n        \"desc\": partial(desc),\n        \"asc\": partial(asc),\n    }\n\n    for value in order_by:\n        if isinstance(value, str):\n            self._validate_mapped_property(value)\n            stmt = stmt.order_by(getattr(self._model, value))\n        else:\n            self._validate_mapped_property(value[0])\n            stmt = stmt.order_by(\n                _partial_registry[value[1]](getattr(self._model, value[0]))\n            )\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._find_query","title":"_find_query","text":"<pre><code>_find_query(\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; Select\n</code></pre> <p>Build a query with column filters and orders.</p> <p>E.g. q = _find_query(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>q = _find_query(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>q = _find_query(order_by=[(\"name\", \"desc\")])     finds all models with reversed order by <code>name</code> column</p> <p>Parameters:</p> Name Type Description Default <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>Any keyword argument to be used as equality filter</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <p>a list of columns, or tuples (column, direction)</p> <code>None</code> <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _find_query(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; Select:\n    \"\"\"Build a query with column filters and orders.\n\n    E.g.\n    q = _find_query(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    q = _find_query(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    q = _find_query(order_by=[(\"name\", \"desc\")])\n        finds all models with reversed order by `name` column\n\n    :param search_params: Any keyword argument to be used as equality filter\n    :param order_by: a list of columns, or tuples (column, direction)\n    :return: The filtered query\n    \"\"\"\n    stmt = select(self._model)\n\n    if search_params:\n        stmt = self._filter_select(stmt, search_params)\n    if order_by is not None:\n        stmt = self._filter_order_by(stmt, order_by)\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._paginate_query_by_page","title":"_paginate_query_by_page","text":"<pre><code>_paginate_query_by_page(\n    stmt: Select, page: int, items_per_page: int\n) -&gt; Select\n</code></pre> <p>Build the query offset and limit clauses from submitted parameters.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>page</code> <code>int</code> <p>Number of models to skip</p> required <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _paginate_query_by_page(\n    self,\n    stmt: Select,\n    page: int,\n    items_per_page: int,\n) -&gt; Select:\n    \"\"\"Build the query offset and limit clauses from submitted parameters.\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param page: Number of models to skip\n    :type page: int\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :return: The filtered query\n    \"\"\"\n\n    _offset = max((page - 1) * items_per_page, 0)\n    if _offset &gt; 0:\n        stmt = stmt.offset(_offset)\n\n    _limit = self._sanitised_query_limit(items_per_page)\n    stmt = stmt.limit(_limit)\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._cursor_paginated_query","title":"_cursor_paginated_query","text":"<pre><code>_cursor_paginated_query(\n    stmt: Select,\n    cursor_reference: Union[CursorReference, None],\n    is_before_cursor: bool = False,\n    items_per_page: int = _max_query_limit,\n) -&gt; Select\n</code></pre> <p>Adds the clauses to retrieve the requested slice of models, after or before the cursor value, plus a model before the slice and one after the slice, to identify if previous or next results are available.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>Union[CursorReference, None]</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> <code>False</code> <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> <code>_max_query_limit</code> <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_paginated_query(\n    self,\n    stmt: Select,\n    cursor_reference: Union[CursorReference, None],\n    is_before_cursor: bool = False,\n    items_per_page: int = _max_query_limit,\n) -&gt; Select:\n    \"\"\"Adds the clauses to retrieve the requested slice of models, after\n    or before the cursor value, plus a model before the slice and one after\n    the slice, to identify if previous or next results are available.\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :return: The filtered query\n    \"\"\"\n    forward_limit = self._sanitised_query_limit(items_per_page) + 1\n\n    if not cursor_reference:\n        return stmt.limit(forward_limit).order_by(  # type: ignore\n            asc(self._model_pk())\n        )\n\n    previous_query = self._cursor_pagination_previous_item_query(\n        stmt, cursor_reference, is_before_cursor\n    ).subquery(\"previous\")\n\n    page_query = self._cursor_pagination_slice_query(\n        stmt, cursor_reference, forward_limit, is_before_cursor\n    ).subquery(\"slice\")\n\n    query = select(\n        aliased(\n            self._model,\n            select(previous_query)\n            .union_all(select(page_query))\n            .order_by(cursor_reference.column)\n            .subquery(\"cursor_pagination\"),  # type: ignore\n        )\n    )\n    return query\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._cursor_pagination_slice_query","title":"_cursor_pagination_slice_query","text":"<pre><code>_cursor_pagination_slice_query(\n    stmt: Select,\n    cursor_reference: CursorReference,\n    limit: int,\n    is_before_cursor: bool,\n)\n</code></pre> <p>Adds the clauses to retrieve a requested slice of models, after or before the cursor value (excluding the cursor itself)</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>CursorReference</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> required <code>limit</code> <code>int</code> <p>Number of models to retrieve</p> required <p>Returns:</p> Type Description <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_pagination_slice_query(\n    self,\n    stmt: Select,\n    cursor_reference: CursorReference,\n    limit: int,\n    is_before_cursor: bool,\n):\n    \"\"\"Adds the clauses to retrieve a requested slice of models,\n    after or before the cursor value (excluding the cursor itself)\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param limit: Number of models to retrieve\n    :type limit: int\n    :return: The filtered query\n    \"\"\"\n    if not is_before_cursor:\n        page_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &gt; cursor_reference.value\n        )\n        page_query = self._filter_order_by(\n            page_query, [(cursor_reference.column, \"asc\")]\n        )\n    else:\n        page_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &lt; cursor_reference.value\n        )\n        page_query = self._filter_order_by(\n            page_query, [(cursor_reference.column, \"desc\")]\n        )\n    return page_query.limit(limit)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._cursor_pagination_previous_item_query","title":"_cursor_pagination_previous_item_query","text":"<pre><code>_cursor_pagination_previous_item_query(\n    stmt: Select,\n    cursor_reference: CursorReference,\n    is_before_cursor: bool,\n) -&gt; Select\n</code></pre> <p>Adds the clauses to retrieve a single model, after or before the cursor value (including the cursor itself).</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>CursorReference</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_pagination_previous_item_query(\n    self, stmt: Select, cursor_reference: CursorReference, is_before_cursor: bool\n) -&gt; Select:\n    \"\"\"Adds the clauses to retrieve a single model, after or before\n    the cursor value (including the cursor itself).\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :return: The filtered query\n    \"\"\"\n    if not is_before_cursor:\n        previous_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &lt;= cursor_reference.value\n        )\n        previous_query = self._filter_order_by(\n            previous_query, [(cursor_reference.column, \"desc\")]\n        )\n    else:\n        previous_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &gt;= cursor_reference.value\n        )\n        previous_query = self._filter_order_by(\n            previous_query, [(cursor_reference.column, \"asc\")]\n        )\n\n    return previous_query.limit(1)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository._model_pk","title":"_model_pk","text":"<pre><code>_model_pk() -&gt; str\n</code></pre> <p>Retrieves the primary key name from the repository model class.</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _model_pk(self) -&gt; str:\n    \"\"\"\n    Retrieves the primary key name from the repository model class.\n\n    :return:\n    \"\"\"\n    primary_keys = inspect(self._model).primary_key  # type: ignore\n    if len(primary_keys) &gt; 1:\n        raise NotImplementedError(\"Composite primary keys are not supported.\")\n\n    return primary_keys[0].name\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.get","title":"get","text":"<pre><code>get(identifier: PRIMARY_KEY) -&gt; MODEL\n</code></pre> <p>Get a model by primary key.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>PRIMARY_KEY</code> <p>The primary key</p> required <p>Returns:</p> Type Description <code>MODEL</code> <p>A model instance</p> <p>Raises:</p> Type Description <code>ModelNotFoundError</code> <p>No model has been found using the primary key</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n    \"\"\"Get a model by primary key.\n\n    :param identifier: The primary key\n    :return: A model instance\n    :raises ModelNotFoundError: No model has been found using the primary key\n    \"\"\"\n    with self._get_session(commit=False) as session:\n        model = session.get(self._model, identifier)\n    if model is None:\n        raise ModelNotFoundError(\"No rows found for provided primary key.\")\n    return model\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.get_many","title":"get_many","text":"<pre><code>get_many(identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]\n</code></pre> <p>Get a list of models by primary keys.</p> <p>Parameters:</p> Name Type Description Default <code>identifiers</code> <code>Iterable[PRIMARY_KEY]</code> <p>A list of primary keys</p> required <p>Returns:</p> Type Description <code>List[MODEL]</code> <p>A list of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n    \"\"\"Get a list of models by primary keys.\n\n    :param identifiers: A list of primary keys\n    :return: A list of models\n    \"\"\"\n    stmt = select(self._model).where(\n        getattr(self._model, self._model_pk()).in_(identifiers)\n    )\n\n    with self._get_session(commit=False) as session:\n        return [x for x in session.execute(stmt).scalars()]\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.save","title":"save","text":"<pre><code>save(instance: MODEL) -&gt; MODEL\n</code></pre> <p>Persist a model.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>MODEL</code> <p>A mapped object instance to be persisted</p> required <p>Returns:</p> Type Description <code>MODEL</code> <p>The model instance after being persisted</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def save(self, instance: MODEL) -&gt; MODEL:\n    \"\"\"Persist a model.\n\n    :param instance: A mapped object instance to be persisted\n    :return: The model instance after being persisted\n    \"\"\"\n    self._fail_if_invalid_models([instance])\n    with self._get_session() as session:\n        session.add(instance)\n    return instance\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.save_many","title":"save_many","text":"<pre><code>save_many(instances: Iterable[MODEL]) -&gt; Iterable[MODEL]\n</code></pre> <p>Persist many models in a single database get_session.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Iterable[MODEL]</code> <p>A list of mapped objects to be persisted</p> required <p>Returns:</p> Type Description <code>Iterable[MODEL]</code> <p>The model instances after being persisted</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def save_many(self, instances: Iterable[MODEL]) -&gt; Iterable[MODEL]:\n    \"\"\"Persist many models in a single database get_session.\n\n    :param instances: A list of mapped objects to be persisted\n    :return: The model instances after being persisted\n    \"\"\"\n    self._fail_if_invalid_models(instances)\n    with self._get_session() as session:\n        session.add_all(instances)\n    return instances\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.delete","title":"delete","text":"<pre><code>delete(instance: MODEL) -&gt; None\n</code></pre> <p>Deletes a model.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>MODEL</code> <p>The model instance</p> required Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def delete(self, instance: MODEL) -&gt; None:\n    \"\"\"Deletes a model.\n\n    :param instance: The model instance\n    \"\"\"\n    self._fail_if_invalid_models([instance])\n    with self._get_session() as session:\n        session.delete(instance)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.delete_many","title":"delete_many","text":"<pre><code>delete_many(instances: Iterable[MODEL]) -&gt; None\n</code></pre> <p>Deletes a collection of models in a single transaction.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Iterable[MODEL]</code> <p>The model instances</p> required Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n    \"\"\"Deletes a collection of models in a single transaction.\n\n    :param instances: The model instances\n    \"\"\"\n    self._fail_if_invalid_models(instances)\n    with self._get_session() as session:\n        for model in instances:\n            session.delete(model)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.find","title":"find","text":"<pre><code>find(\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; List[MODEL]\n</code></pre> <p>Find models using filters.</p> <p>E.g.</p> <pre><code># find all models with name = John\nfind(search_params={\"name\":\"John\"})\n\n# find all models ordered by `name` column\nfind(order_by=[\"name\"])\n\n# find all models with reversed order by `name` column\nfind(order_by=[(\"name\", \"desc\")])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def find(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; List[MODEL]:\n    \"\"\"Find models using filters.\n\n    E.g.\n\n        # find all models with name = John\n        find(search_params={\"name\":\"John\"})\n\n        # find all models ordered by `name` column\n        find(order_by=[\"name\"])\n\n        # find all models with reversed order by `name` column\n        find(order_by=[(\"name\", \"desc\")])\n\n    :param search_params: A mapping containing equality filters\n    :param order_by:\n    :return: A collection of models\n    \"\"\"\n    stmt = self._find_query(search_params, order_by)\n\n    with self._get_session() as session:\n        result = session.execute(stmt)\n        return [x for x in result.scalars()]\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.paginated_find","title":"paginated_find","text":"<pre><code>paginated_find(\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; PaginatedResult[MODEL]\n</code></pre> <p>Find models using filters and limit/offset pagination. Returned results do include pagination metadata.</p> <p>E.g.</p> <pre><code># find all models with name = John\npaginated_find(search_params={\"name\":\"John\"})\n\n# find first 50 models with name = John\npaginated_find(50, search_params={\"name\":\"John\"})\n\n# find 50 models with name = John, skipping 2 pages (100)\npaginated_find(50, 3, search_params={\"name\":\"John\"})\n\n# find all models ordered by `name` column\npaginated_find(order_by=[\"name\"])\n\n# find all models with reversed order by `name` column\npaginated_find(order_by=[(\"name\", \"desc\")])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <code>page</code> <code>int</code> <p>Page to retrieve</p> <code>1</code> <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResult[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def paginated_find(\n    self,\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; PaginatedResult[MODEL]:\n    \"\"\"Find models using filters and limit/offset pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n\n        # find all models with name = John\n        paginated_find(search_params={\"name\":\"John\"})\n\n        # find first 50 models with name = John\n        paginated_find(50, search_params={\"name\":\"John\"})\n\n        # find 50 models with name = John, skipping 2 pages (100)\n        paginated_find(50, 3, search_params={\"name\":\"John\"})\n\n        # find all models ordered by `name` column\n        paginated_find(order_by=[\"name\"])\n\n        # find all models with reversed order by `name` column\n        paginated_find(order_by=[(\"name\", \"desc\")])\n\n    :param items_per_page: Number of models to retrieve\n    :param page: Page to retrieve\n    :param search_params: A mapping containing equality filters\n    :param order_by:\n    :return: A collection of models\n    \"\"\"\n    find_stmt = self._find_query(search_params, order_by)\n    paginated_stmt = self._paginate_query_by_page(find_stmt, page, items_per_page)\n\n    with self._get_session() as session:\n        total_items_count = (\n            session.execute(self._count_query(find_stmt)).scalar() or 0\n        )\n        result_items = [x for x in session.execute(paginated_stmt).scalars()]\n\n        return PaginatedResultPresenter.build_result(\n            result_items=result_items,\n            total_items_count=total_items_count,\n            page=page,\n            items_per_page=self._sanitised_query_limit(items_per_page),\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyRepository.cursor_paginated_find","title":"cursor_paginated_find","text":"<pre><code>cursor_paginated_find(\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]\n</code></pre> <p>Find models using filters and cursor based pagination. Returned results do include pagination metadata.</p> <p>E.g.</p> <pre><code># finds all models with name = John\ncursor_paginated_find(search_params={\"name\":\"John\"})\n\n# finds first 50 models with name = John\ncursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n# finds first 50 models after the one with \"id\" 123\ncursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n# finds last 50 models before the one with \"id\" 123\ncursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <code>cursor_reference</code> <code>Union[CursorReference, None]</code> <p>A cursor reference containing ordering column and threshold value</p> <code>None</code> <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> <code>False</code> <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <p>Returns:</p> Type Description <code>CursorPaginatedResult[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/sync.py</code> <pre><code>def cursor_paginated_find(\n    self,\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]:\n    \"\"\"Find models using filters and cursor based pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n\n        # finds all models with name = John\n        cursor_paginated_find(search_params={\"name\":\"John\"})\n\n        # finds first 50 models with name = John\n        cursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n        # finds first 50 models after the one with \"id\" 123\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n        # finds last 50 models before the one with \"id\" 123\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n\n    :param items_per_page: Number of models to retrieve\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :param search_params: A mapping containing equality filters\n    :return: A collection of models\n    \"\"\"\n    find_stmt = self._find_query(search_params)\n\n    paginated_stmt = self._cursor_paginated_query(\n        find_stmt,\n        cursor_reference=cursor_reference,\n        is_before_cursor=is_before_cursor,\n        items_per_page=items_per_page,\n    )\n\n    with self._get_session() as session:\n        total_items_count = (\n            session.execute(self._count_query(find_stmt)).scalar() or 0\n        )\n        result_items = [x for x in session.execute(paginated_stmt).scalars()]\n\n        return CursorPaginatedResultPresenter.build_result(\n            result_items=result_items,\n            total_items_count=total_items_count,\n            items_per_page=self._sanitised_query_limit(items_per_page),\n            cursor_reference=cursor_reference,\n            is_before_cursor=is_before_cursor,\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository","title":"sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository","text":"Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>class SQLAlchemyAsyncRepository(\n    Generic[MODEL],\n    BaseRepository[MODEL],\n):\n    _session_handler: AsyncSessionHandler\n    _external_session: Union[AsyncSession, None]\n\n    def __init__(\n        self,\n        bind: Union[SQLAlchemyAsyncBind, None] = None,\n        session: Union[AsyncSession, None] = None,\n        model_class: Union[Type[MODEL], None] = None,\n    ) -&gt; None:\n        super().__init__(model_class=model_class)\n        if not (bool(bind) ^ bool(session)):\n            raise InvalidConfigError(\n                \"Either `bind` or `session` have to be used, not both\"\n            )\n        self._external_session = session\n        if bind:\n            self._session_handler = AsyncSessionHandler(bind)\n\n    async def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n        \"\"\"Get a model by primary key.\n\n        :param identifier: The primary key\n        :return: A model instance\n        :raises ModelNotFoundError: No model has been found using the primary key\n        \"\"\"\n        async with self._get_session(commit=False) as session:\n            model = await session.get(self._model, identifier)\n        if model is None:\n            raise ModelNotFoundError(\"No rows found for provided primary key.\")\n        return model\n\n    async def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n        \"\"\"Get a list of models by primary keys.\n\n        :param identifiers: A list of primary keys\n        :return: A list of models\n        \"\"\"\n        stmt = select(self._model).where(\n            getattr(self._model, self._model_pk()).in_(identifiers)\n        )\n\n        async with self._get_session(commit=False) as session:\n            return [x for x in (await session.execute(stmt)).scalars()]\n\n    async def save(self, instance: MODEL) -&gt; MODEL:\n        \"\"\"Persist a model.\n\n        :param instance: A mapped object instance to be persisted\n        :return: The model instance after being persisted\n        \"\"\"\n        self._fail_if_invalid_models([instance])\n        async with self._get_session() as session:\n            session.add(instance)\n        return instance\n\n    async def save_many(\n        self,\n        instances: Iterable[MODEL],\n    ) -&gt; Iterable[MODEL]:\n        \"\"\"Persist many models in a single database get_session.\n\n        :param instances: A list of mapped objects to be persisted\n        :return: The model instances after being persisted\n        \"\"\"\n        self._fail_if_invalid_models(instances)\n        async with self._get_session() as session:\n            session.add_all(instances)\n        return instances\n\n    async def delete(self, instance: MODEL) -&gt; None:\n        \"\"\"Deletes a model.\n\n        :param instance: The model instance\n        \"\"\"\n        self._fail_if_invalid_models([instance])\n        async with self._get_session() as session:\n            await session.delete(instance)\n\n    async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n        \"\"\"Deletes a collection of models in a single transaction.\n\n        :param instances: The model instances\n        \"\"\"\n        self._fail_if_invalid_models(instances)\n        async with self._get_session() as session:\n            for instance in instances:\n                await session.delete(instance)\n\n    async def find(\n        self,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[\n            None,\n            Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n        ] = None,\n    ) -&gt; List[MODEL]:\n        \"\"\"Find models using filters.\n\n        E.g.\n\n            # find all models with name = John\n            find(search_params={\"name\":\"John\"})\n\n            # find all models ordered by `name` column\n            find(order_by=[\"name\"])\n\n            # find all models with reversed order by `name` column\n            find(order_by=[(\"name\", \"desc\")])\n\n        :param search_params: A mapping containing equality filters\n        :param order_by:\n        :return: A collection of models\n        \"\"\"\n        stmt = self._find_query(search_params, order_by)\n\n        async with self._get_session() as session:\n            result = await session.execute(stmt)\n            return [x for x in result.scalars()]\n\n    async def paginated_find(\n        self,\n        items_per_page: int,\n        page: int = 1,\n        search_params: Union[None, Mapping[str, Any]] = None,\n        order_by: Union[\n            None,\n            Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n        ] = None,\n    ) -&gt; PaginatedResult[MODEL]:\n        \"\"\"Find models using filters and limit/offset pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n\n            # find all models with name = John\n            paginated_find(search_params={\"name\":\"John\"})\n\n            # find first 50 models with name = John\n            paginated_find(50, search_params={\"name\":\"John\"})\n\n            # find 50 models with name = John, skipping 2 pages (100)\n            paginated_find(50, 3, search_params={\"name\":\"John\"})\n\n            # find all models ordered by `name` column\n            paginated_find(order_by=[\"name\"])\n\n            # find all models with reversed order by `name` column\n            paginated_find(order_by=[(\"name\", \"desc\")])\n\n        :param items_per_page: Number of models to retrieve\n        :param page: Page to retrieve\n        :param search_params: A mapping containing equality filters\n        :param order_by:\n        :return: A collection of models\n        \"\"\"\n        find_stmt = self._find_query(search_params, order_by)\n        paginated_stmt = self._paginate_query_by_page(find_stmt, page, items_per_page)\n\n        async with self._get_session() as session:\n            total_items_count = (\n                await session.execute(self._count_query(find_stmt))\n            ).scalar() or 0\n            result_items = [\n                x for x in (await session.execute(paginated_stmt)).scalars()\n            ]\n\n            return PaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                page=page,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n            )\n\n    async def cursor_paginated_find(\n        self,\n        items_per_page: int,\n        cursor_reference: Union[CursorReference, None] = None,\n        is_before_cursor: bool = False,\n        search_params: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; CursorPaginatedResult[MODEL]:\n        \"\"\"Find models using filters and cursor based pagination. Returned results\n        do include pagination metadata.\n\n        E.g.\n\n            # finds all models with name = John\n            cursor_paginated_find(search_params={\"name\":\"John\"})\n\n            # finds first 50 models with name = John\n            cursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n            # finds first 50 models after the one with \"id\" 123\n            cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n            # finds last 50 models before the one with \"id\" 123\n            cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n\n        :param items_per_page: Number of models to retrieve\n        :param cursor_reference: A cursor reference containing ordering column\n            and threshold value\n        :param is_before_cursor: If True it will return items before the cursor,\n            otherwise items after\n        :param search_params: A mapping containing equality filters\n        :return: A collection of models\n        \"\"\"\n        find_stmt = self._find_query(search_params)\n        paginated_stmt = self._cursor_paginated_query(\n            find_stmt,\n            cursor_reference=cursor_reference,\n            is_before_cursor=is_before_cursor,\n            items_per_page=items_per_page,\n        )\n\n        async with self._get_session() as session:\n            total_items_count = (\n                await session.execute(self._count_query(find_stmt))\n            ).scalar() or 0\n            result_items = [\n                x for x in (await session.execute(paginated_stmt)).scalars()\n            ] or []\n\n            return CursorPaginatedResultPresenter.build_result(\n                result_items=result_items,\n                total_items_count=total_items_count,\n                items_per_page=self._sanitised_query_limit(items_per_page),\n                cursor_reference=cursor_reference,\n                is_before_cursor=is_before_cursor,\n            )\n\n    @asynccontextmanager\n    async def _get_session(self, commit: bool = True) -&gt; AsyncIterator[AsyncSession]:\n        if not self._external_session:\n            async with self._session_handler.get_session(not commit) as _session:\n                yield _session\n        else:\n            yield self._external_session\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._is_mapped_class","title":"_is_mapped_class","text":"<pre><code>_is_mapped_class(class_: Type[MODEL]) -&gt; bool\n</code></pre> <p>Checks if the class is mapped in SQLAlchemy.</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>Type[MODEL]</code> <p>the model class</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the Type is mapped, False otherwise</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _is_mapped_class(self, class_: Type[MODEL]) -&gt; bool:\n    \"\"\"Checks if the class is mapped in SQLAlchemy.\n\n    :param class_: the model class\n    :return: True if the Type is mapped, False otherwise\n    :rtype: bool\n    \"\"\"\n    try:\n        class_mapper(class_)\n        return True\n    except UnmappedClassError:\n        return False\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._validate_mapped_property","title":"_validate_mapped_property","text":"<pre><code>_validate_mapped_property(property_name: str) -&gt; None\n</code></pre> <p>Checks if a property is mapped in the model class.</p> <p>Parameters:</p> Name Type Description Default <code>property_name</code> <code>str</code> <p>The name of the property to be evaluated.</p> required <p>Raises:</p> Type Description <code>UnmappedPropertyError</code> <p>When the property is not mapped.</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _validate_mapped_property(self, property_name: str) -&gt; None:\n    \"\"\"Checks if a property is mapped in the model class.\n\n    :param property_name: The name of the property to be evaluated.\n    :type property_name: str\n    :raises UnmappedPropertyError: When the property is not mapped.\n    \"\"\"\n    m: Mapper = class_mapper(self._model)\n    if property_name not in m.column_attrs:\n        raise UnmappedPropertyError(\n            f\"Property `{property_name}` is not mapped\"\n            f\" in the ORM for model `{self._model}`\"\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._filter_select","title":"_filter_select","text":"<pre><code>_filter_select(\n    stmt: Select, search_params: Mapping[str, Any]\n) -&gt; Select\n</code></pre> <p>Build the query filtering clauses from submitted parameters.</p> <p>E.g. _filter_select(stmt, name=\"John\") adds a <code>WHERE name = John</code> statement</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>search_params</code> <code>Mapping[str, Any]</code> <p>Any keyword argument to be used as equality filter</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _filter_select(self, stmt: Select, search_params: Mapping[str, Any]) -&gt; Select:\n    \"\"\"Build the query filtering clauses from submitted parameters.\n\n    E.g.\n    _filter_select(stmt, name=\"John\") adds a `WHERE name = John` statement\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param search_params: Any keyword argument to be used as equality filter\n    :type search_params: Mapping[str, Any]\n    :return: The filtered query\n    \"\"\"\n    # TODO: Add support for relationship eager load\n    for k, v in search_params.items():\n        \"\"\"\n        This acts as a TypeGuard but using TypeGuard typing would break\n        compatibility with python &lt; 3.10, for the moment we prefer to ignore\n        typing issues here\n        \"\"\"\n        self._validate_mapped_property(k)\n        stmt = stmt.where(getattr(self._model, k) == v)\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._filter_order_by","title":"_filter_order_by","text":"<pre><code>_filter_order_by(\n    stmt: Select,\n    order_by: Iterable[\n        Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n    ],\n) -&gt; Select\n</code></pre> <p>Build the query ordering clauses from submitted parameters.</p> <p>E.g. <code>_filter_order_by(stmt, ['name'])</code>     adds a <code>ORDER BY name</code> statement</p> <p><code>_filter_order_by(stmt, [('name', 'asc')])</code>     adds a <code>ORDER BY name ASC</code> statement</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>order_by</code> <code>Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]</code> <p>a list of columns, or tuples (column, direction)</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _filter_order_by(\n    self,\n    stmt: Select,\n    order_by: Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n) -&gt; Select:\n    \"\"\"Build the query ordering clauses from submitted parameters.\n\n    E.g.\n    `_filter_order_by(stmt, ['name'])`\n        adds a `ORDER BY name` statement\n\n    `_filter_order_by(stmt, [('name', 'asc')])`\n        adds a `ORDER BY name ASC` statement\n\n    :param stmt: a Select statement\n    :param order_by: a list of columns, or tuples (column, direction)\n    :return: The filtered query\n    \"\"\"\n    _partial_registry: Dict[Literal[\"asc\", \"desc\"], Callable] = {\n        \"desc\": partial(desc),\n        \"asc\": partial(asc),\n    }\n\n    for value in order_by:\n        if isinstance(value, str):\n            self._validate_mapped_property(value)\n            stmt = stmt.order_by(getattr(self._model, value))\n        else:\n            self._validate_mapped_property(value[0])\n            stmt = stmt.order_by(\n                _partial_registry[value[1]](getattr(self._model, value[0]))\n            )\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._find_query","title":"_find_query","text":"<pre><code>_find_query(\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; Select\n</code></pre> <p>Build a query with column filters and orders.</p> <p>E.g. q = _find_query(search_params={\"name\":\"John\"})     finds all models with name = John</p> <p>q = _find_query(order_by=[\"name\"])     finds all models ordered by <code>name</code> column</p> <p>q = _find_query(order_by=[(\"name\", \"desc\")])     finds all models with reversed order by <code>name</code> column</p> <p>Parameters:</p> Name Type Description Default <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>Any keyword argument to be used as equality filter</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <p>a list of columns, or tuples (column, direction)</p> <code>None</code> <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _find_query(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; Select:\n    \"\"\"Build a query with column filters and orders.\n\n    E.g.\n    q = _find_query(search_params={\"name\":\"John\"})\n        finds all models with name = John\n\n    q = _find_query(order_by=[\"name\"])\n        finds all models ordered by `name` column\n\n    q = _find_query(order_by=[(\"name\", \"desc\")])\n        finds all models with reversed order by `name` column\n\n    :param search_params: Any keyword argument to be used as equality filter\n    :param order_by: a list of columns, or tuples (column, direction)\n    :return: The filtered query\n    \"\"\"\n    stmt = select(self._model)\n\n    if search_params:\n        stmt = self._filter_select(stmt, search_params)\n    if order_by is not None:\n        stmt = self._filter_order_by(stmt, order_by)\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._paginate_query_by_page","title":"_paginate_query_by_page","text":"<pre><code>_paginate_query_by_page(\n    stmt: Select, page: int, items_per_page: int\n) -&gt; Select\n</code></pre> <p>Build the query offset and limit clauses from submitted parameters.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>page</code> <code>int</code> <p>Number of models to skip</p> required <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _paginate_query_by_page(\n    self,\n    stmt: Select,\n    page: int,\n    items_per_page: int,\n) -&gt; Select:\n    \"\"\"Build the query offset and limit clauses from submitted parameters.\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param page: Number of models to skip\n    :type page: int\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :return: The filtered query\n    \"\"\"\n\n    _offset = max((page - 1) * items_per_page, 0)\n    if _offset &gt; 0:\n        stmt = stmt.offset(_offset)\n\n    _limit = self._sanitised_query_limit(items_per_page)\n    stmt = stmt.limit(_limit)\n\n    return stmt\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._cursor_paginated_query","title":"_cursor_paginated_query","text":"<pre><code>_cursor_paginated_query(\n    stmt: Select,\n    cursor_reference: Union[CursorReference, None],\n    is_before_cursor: bool = False,\n    items_per_page: int = _max_query_limit,\n) -&gt; Select\n</code></pre> <p>Adds the clauses to retrieve the requested slice of models, after or before the cursor value, plus a model before the slice and one after the slice, to identify if previous or next results are available.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>Union[CursorReference, None]</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> <code>False</code> <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> <code>_max_query_limit</code> <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_paginated_query(\n    self,\n    stmt: Select,\n    cursor_reference: Union[CursorReference, None],\n    is_before_cursor: bool = False,\n    items_per_page: int = _max_query_limit,\n) -&gt; Select:\n    \"\"\"Adds the clauses to retrieve the requested slice of models, after\n    or before the cursor value, plus a model before the slice and one after\n    the slice, to identify if previous or next results are available.\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param items_per_page: Number of models to retrieve\n    :type items_per_page: int\n    :return: The filtered query\n    \"\"\"\n    forward_limit = self._sanitised_query_limit(items_per_page) + 1\n\n    if not cursor_reference:\n        return stmt.limit(forward_limit).order_by(  # type: ignore\n            asc(self._model_pk())\n        )\n\n    previous_query = self._cursor_pagination_previous_item_query(\n        stmt, cursor_reference, is_before_cursor\n    ).subquery(\"previous\")\n\n    page_query = self._cursor_pagination_slice_query(\n        stmt, cursor_reference, forward_limit, is_before_cursor\n    ).subquery(\"slice\")\n\n    query = select(\n        aliased(\n            self._model,\n            select(previous_query)\n            .union_all(select(page_query))\n            .order_by(cursor_reference.column)\n            .subquery(\"cursor_pagination\"),  # type: ignore\n        )\n    )\n    return query\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._cursor_pagination_slice_query","title":"_cursor_pagination_slice_query","text":"<pre><code>_cursor_pagination_slice_query(\n    stmt: Select,\n    cursor_reference: CursorReference,\n    limit: int,\n    is_before_cursor: bool,\n)\n</code></pre> <p>Adds the clauses to retrieve a requested slice of models, after or before the cursor value (excluding the cursor itself)</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>CursorReference</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> required <code>limit</code> <code>int</code> <p>Number of models to retrieve</p> required <p>Returns:</p> Type Description <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_pagination_slice_query(\n    self,\n    stmt: Select,\n    cursor_reference: CursorReference,\n    limit: int,\n    is_before_cursor: bool,\n):\n    \"\"\"Adds the clauses to retrieve a requested slice of models,\n    after or before the cursor value (excluding the cursor itself)\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :param limit: Number of models to retrieve\n    :type limit: int\n    :return: The filtered query\n    \"\"\"\n    if not is_before_cursor:\n        page_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &gt; cursor_reference.value\n        )\n        page_query = self._filter_order_by(\n            page_query, [(cursor_reference.column, \"asc\")]\n        )\n    else:\n        page_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &lt; cursor_reference.value\n        )\n        page_query = self._filter_order_by(\n            page_query, [(cursor_reference.column, \"desc\")]\n        )\n    return page_query.limit(limit)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._cursor_pagination_previous_item_query","title":"_cursor_pagination_previous_item_query","text":"<pre><code>_cursor_pagination_previous_item_query(\n    stmt: Select,\n    cursor_reference: CursorReference,\n    is_before_cursor: bool,\n) -&gt; Select\n</code></pre> <p>Adds the clauses to retrieve a single model, after or before the cursor value (including the cursor itself).</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Select</code> <p>a Select statement</p> required <code>cursor_reference</code> <code>CursorReference</code> <p>A cursor reference containing ordering column and threshold value</p> required <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The filtered query</p> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _cursor_pagination_previous_item_query(\n    self, stmt: Select, cursor_reference: CursorReference, is_before_cursor: bool\n) -&gt; Select:\n    \"\"\"Adds the clauses to retrieve a single model, after or before\n    the cursor value (including the cursor itself).\n\n    :param stmt: a Select statement\n    :type stmt: Select\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :type cursor_reference: Union[CursorReference, None]\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :type is_before_cursor: bool\n    :return: The filtered query\n    \"\"\"\n    if not is_before_cursor:\n        previous_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &lt;= cursor_reference.value\n        )\n        previous_query = self._filter_order_by(\n            previous_query, [(cursor_reference.column, \"desc\")]\n        )\n    else:\n        previous_query = stmt.where(\n            getattr(self._model, cursor_reference.column) &gt;= cursor_reference.value\n        )\n        previous_query = self._filter_order_by(\n            previous_query, [(cursor_reference.column, \"asc\")]\n        )\n\n    return previous_query.limit(1)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository._model_pk","title":"_model_pk","text":"<pre><code>_model_pk() -&gt; str\n</code></pre> <p>Retrieves the primary key name from the repository model class.</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>sqlalchemy_bind_manager/_repository/base_repository.py</code> <pre><code>def _model_pk(self) -&gt; str:\n    \"\"\"\n    Retrieves the primary key name from the repository model class.\n\n    :return:\n    \"\"\"\n    primary_keys = inspect(self._model).primary_key  # type: ignore\n    if len(primary_keys) &gt; 1:\n        raise NotImplementedError(\"Composite primary keys are not supported.\")\n\n    return primary_keys[0].name\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.get","title":"get  <code>async</code>","text":"<pre><code>get(identifier: PRIMARY_KEY) -&gt; MODEL\n</code></pre> <p>Get a model by primary key.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>PRIMARY_KEY</code> <p>The primary key</p> required <p>Returns:</p> Type Description <code>MODEL</code> <p>A model instance</p> <p>Raises:</p> Type Description <code>ModelNotFoundError</code> <p>No model has been found using the primary key</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def get(self, identifier: PRIMARY_KEY) -&gt; MODEL:\n    \"\"\"Get a model by primary key.\n\n    :param identifier: The primary key\n    :return: A model instance\n    :raises ModelNotFoundError: No model has been found using the primary key\n    \"\"\"\n    async with self._get_session(commit=False) as session:\n        model = await session.get(self._model, identifier)\n    if model is None:\n        raise ModelNotFoundError(\"No rows found for provided primary key.\")\n    return model\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]\n</code></pre> <p>Get a list of models by primary keys.</p> <p>Parameters:</p> Name Type Description Default <code>identifiers</code> <code>Iterable[PRIMARY_KEY]</code> <p>A list of primary keys</p> required <p>Returns:</p> Type Description <code>List[MODEL]</code> <p>A list of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def get_many(self, identifiers: Iterable[PRIMARY_KEY]) -&gt; List[MODEL]:\n    \"\"\"Get a list of models by primary keys.\n\n    :param identifiers: A list of primary keys\n    :return: A list of models\n    \"\"\"\n    stmt = select(self._model).where(\n        getattr(self._model, self._model_pk()).in_(identifiers)\n    )\n\n    async with self._get_session(commit=False) as session:\n        return [x for x in (await session.execute(stmt)).scalars()]\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.save","title":"save  <code>async</code>","text":"<pre><code>save(instance: MODEL) -&gt; MODEL\n</code></pre> <p>Persist a model.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>MODEL</code> <p>A mapped object instance to be persisted</p> required <p>Returns:</p> Type Description <code>MODEL</code> <p>The model instance after being persisted</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def save(self, instance: MODEL) -&gt; MODEL:\n    \"\"\"Persist a model.\n\n    :param instance: A mapped object instance to be persisted\n    :return: The model instance after being persisted\n    \"\"\"\n    self._fail_if_invalid_models([instance])\n    async with self._get_session() as session:\n        session.add(instance)\n    return instance\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.save_many","title":"save_many  <code>async</code>","text":"<pre><code>save_many(instances: Iterable[MODEL]) -&gt; Iterable[MODEL]\n</code></pre> <p>Persist many models in a single database get_session.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Iterable[MODEL]</code> <p>A list of mapped objects to be persisted</p> required <p>Returns:</p> Type Description <code>Iterable[MODEL]</code> <p>The model instances after being persisted</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def save_many(\n    self,\n    instances: Iterable[MODEL],\n) -&gt; Iterable[MODEL]:\n    \"\"\"Persist many models in a single database get_session.\n\n    :param instances: A list of mapped objects to be persisted\n    :return: The model instances after being persisted\n    \"\"\"\n    self._fail_if_invalid_models(instances)\n    async with self._get_session() as session:\n        session.add_all(instances)\n    return instances\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(instance: MODEL) -&gt; None\n</code></pre> <p>Deletes a model.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>MODEL</code> <p>The model instance</p> required Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def delete(self, instance: MODEL) -&gt; None:\n    \"\"\"Deletes a model.\n\n    :param instance: The model instance\n    \"\"\"\n    self._fail_if_invalid_models([instance])\n    async with self._get_session() as session:\n        await session.delete(instance)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(instances: Iterable[MODEL]) -&gt; None\n</code></pre> <p>Deletes a collection of models in a single transaction.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Iterable[MODEL]</code> <p>The model instances</p> required Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def delete_many(self, instances: Iterable[MODEL]) -&gt; None:\n    \"\"\"Deletes a collection of models in a single transaction.\n\n    :param instances: The model instances\n    \"\"\"\n    self._fail_if_invalid_models(instances)\n    async with self._get_session() as session:\n        for instance in instances:\n            await session.delete(instance)\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.find","title":"find  <code>async</code>","text":"<pre><code>find(\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; List[MODEL]\n</code></pre> <p>Find models using filters.</p> <p>E.g.</p> <pre><code># find all models with name = John\nfind(search_params={\"name\":\"John\"})\n\n# find all models ordered by `name` column\nfind(order_by=[\"name\"])\n\n# find all models with reversed order by `name` column\nfind(order_by=[(\"name\", \"desc\")])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def find(\n    self,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; List[MODEL]:\n    \"\"\"Find models using filters.\n\n    E.g.\n\n        # find all models with name = John\n        find(search_params={\"name\":\"John\"})\n\n        # find all models ordered by `name` column\n        find(order_by=[\"name\"])\n\n        # find all models with reversed order by `name` column\n        find(order_by=[(\"name\", \"desc\")])\n\n    :param search_params: A mapping containing equality filters\n    :param order_by:\n    :return: A collection of models\n    \"\"\"\n    stmt = self._find_query(search_params, order_by)\n\n    async with self._get_session() as session:\n        result = await session.execute(stmt)\n        return [x for x in result.scalars()]\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.paginated_find","title":"paginated_find  <code>async</code>","text":"<pre><code>paginated_find(\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[\n            Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]\n        ],\n    ] = None,\n) -&gt; PaginatedResult[MODEL]\n</code></pre> <p>Find models using filters and limit/offset pagination. Returned results do include pagination metadata.</p> <p>E.g.</p> <pre><code># find all models with name = John\npaginated_find(search_params={\"name\":\"John\"})\n\n# find first 50 models with name = John\npaginated_find(50, search_params={\"name\":\"John\"})\n\n# find 50 models with name = John, skipping 2 pages (100)\npaginated_find(50, 3, search_params={\"name\":\"John\"})\n\n# find all models ordered by `name` column\npaginated_find(order_by=[\"name\"])\n\n# find all models with reversed order by `name` column\npaginated_find(order_by=[(\"name\", \"desc\")])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <code>page</code> <code>int</code> <p>Page to retrieve</p> <code>1</code> <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <code>order_by</code> <code>Union[None, Iterable[Union[str, Tuple[str, Literal['asc', 'desc']]]]]</code> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResult[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def paginated_find(\n    self,\n    items_per_page: int,\n    page: int = 1,\n    search_params: Union[None, Mapping[str, Any]] = None,\n    order_by: Union[\n        None,\n        Iterable[Union[str, Tuple[str, Literal[\"asc\", \"desc\"]]]],\n    ] = None,\n) -&gt; PaginatedResult[MODEL]:\n    \"\"\"Find models using filters and limit/offset pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n\n        # find all models with name = John\n        paginated_find(search_params={\"name\":\"John\"})\n\n        # find first 50 models with name = John\n        paginated_find(50, search_params={\"name\":\"John\"})\n\n        # find 50 models with name = John, skipping 2 pages (100)\n        paginated_find(50, 3, search_params={\"name\":\"John\"})\n\n        # find all models ordered by `name` column\n        paginated_find(order_by=[\"name\"])\n\n        # find all models with reversed order by `name` column\n        paginated_find(order_by=[(\"name\", \"desc\")])\n\n    :param items_per_page: Number of models to retrieve\n    :param page: Page to retrieve\n    :param search_params: A mapping containing equality filters\n    :param order_by:\n    :return: A collection of models\n    \"\"\"\n    find_stmt = self._find_query(search_params, order_by)\n    paginated_stmt = self._paginate_query_by_page(find_stmt, page, items_per_page)\n\n    async with self._get_session() as session:\n        total_items_count = (\n            await session.execute(self._count_query(find_stmt))\n        ).scalar() or 0\n        result_items = [\n            x for x in (await session.execute(paginated_stmt)).scalars()\n        ]\n\n        return PaginatedResultPresenter.build_result(\n            result_items=result_items,\n            total_items_count=total_items_count,\n            page=page,\n            items_per_page=self._sanitised_query_limit(items_per_page),\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.SQLAlchemyAsyncRepository.cursor_paginated_find","title":"cursor_paginated_find  <code>async</code>","text":"<pre><code>cursor_paginated_find(\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]\n</code></pre> <p>Find models using filters and cursor based pagination. Returned results do include pagination metadata.</p> <p>E.g.</p> <pre><code># finds all models with name = John\ncursor_paginated_find(search_params={\"name\":\"John\"})\n\n# finds first 50 models with name = John\ncursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n# finds first 50 models after the one with \"id\" 123\ncursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n# finds last 50 models before the one with \"id\" 123\ncursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items_per_page</code> <code>int</code> <p>Number of models to retrieve</p> required <code>cursor_reference</code> <code>Union[CursorReference, None]</code> <p>A cursor reference containing ordering column and threshold value</p> <code>None</code> <code>is_before_cursor</code> <code>bool</code> <p>If True it will return items before the cursor, otherwise items after</p> <code>False</code> <code>search_params</code> <code>Union[None, Mapping[str, Any]]</code> <p>A mapping containing equality filters</p> <code>None</code> <p>Returns:</p> Type Description <code>CursorPaginatedResult[MODEL]</code> <p>A collection of models</p> Source code in <code>sqlalchemy_bind_manager/_repository/async_.py</code> <pre><code>async def cursor_paginated_find(\n    self,\n    items_per_page: int,\n    cursor_reference: Union[CursorReference, None] = None,\n    is_before_cursor: bool = False,\n    search_params: Union[None, Mapping[str, Any]] = None,\n) -&gt; CursorPaginatedResult[MODEL]:\n    \"\"\"Find models using filters and cursor based pagination. Returned results\n    do include pagination metadata.\n\n    E.g.\n\n        # finds all models with name = John\n        cursor_paginated_find(search_params={\"name\":\"John\"})\n\n        # finds first 50 models with name = John\n        cursor_paginated_find(50, search_params={\"name\":\"John\"})\n\n        # finds first 50 models after the one with \"id\" 123\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123))\n\n        # finds last 50 models before the one with \"id\" 123\n        cursor_paginated_find(50, CursorReference(column=\"id\", value=123), True)\n\n    :param items_per_page: Number of models to retrieve\n    :param cursor_reference: A cursor reference containing ordering column\n        and threshold value\n    :param is_before_cursor: If True it will return items before the cursor,\n        otherwise items after\n    :param search_params: A mapping containing equality filters\n    :return: A collection of models\n    \"\"\"\n    find_stmt = self._find_query(search_params)\n    paginated_stmt = self._cursor_paginated_query(\n        find_stmt,\n        cursor_reference=cursor_reference,\n        is_before_cursor=is_before_cursor,\n        items_per_page=items_per_page,\n    )\n\n    async with self._get_session() as session:\n        total_items_count = (\n            await session.execute(self._count_query(find_stmt))\n        ).scalar() or 0\n        result_items = [\n            x for x in (await session.execute(paginated_stmt)).scalars()\n        ] or []\n\n        return CursorPaginatedResultPresenter.build_result(\n            result_items=result_items,\n            total_items_count=total_items_count,\n            items_per_page=self._sanitised_query_limit(items_per_page),\n            cursor_reference=cursor_reference,\n            is_before_cursor=is_before_cursor,\n        )\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.PaginatedResult","title":"sqlalchemy_bind_manager.repository.PaginatedResult","text":"<p>The result of a paginated query.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[MODEL]</code> <p>The models returned by the query</p> required <code>page_info</code> <code>PageInfo</code> <p>The pagination metadata</p> required Source code in <code>sqlalchemy_bind_manager/_repository/common.py</code> <pre><code>class PaginatedResult(BaseModel, Generic[MODEL]):\n    \"\"\"\n    The result of a paginated query.\n\n    :param items: The models returned by the query\n    :type items: List[MODEL]\n    :param page_info: The pagination metadata\n    :type page_info: PageInfo\n    \"\"\"\n\n    items: List[MODEL]\n    page_info: PageInfo\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.PageInfo","title":"sqlalchemy_bind_manager.repository.PageInfo","text":"<p>Paginated query metadata.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The current page number</p> required <code>items_per_page</code> <code>int</code> <p>The maximum number of items in a page.</p> required <code>total_pages</code> <code>int</code> <p>The number of available pages.</p> required <code>total_items</code> <code>int</code> <p>The total items in all the pages.</p> required <code>has_next_page</code> <code>bool</code> <p>True if there is a next page.</p> required <code>has_previous_page</code> <code>bool</code> <p>True if there is a previous page.</p> required Source code in <code>sqlalchemy_bind_manager/_repository/common.py</code> <pre><code>class PageInfo(BaseModel):\n    \"\"\"\n    Paginated query metadata.\n\n    :param page: The current page number\n    :type page: int\n    :param items_per_page: The maximum number of items in a page.\n    :type items_per_page: int\n    :param total_pages: The number of available pages.\n    :type total_pages: int\n    :param total_items: The total items in all the pages.\n    :type total_items: int\n    :param has_next_page: True if there is a next page.\n    :type has_next_page: bool\n    :param has_previous_page: True if there is a previous page.\n    :type has_previous_page: bool\n    \"\"\"\n\n    page: int\n    items_per_page: int\n    total_pages: int\n    total_items: int\n    has_next_page: bool\n    has_previous_page: bool\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.CursorPaginatedResult","title":"sqlalchemy_bind_manager.repository.CursorPaginatedResult","text":"<p>The result of a cursor paginated query.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[MODEL]</code> <p>The models returned by the query</p> required <code>page_info</code> <code>CursorPageInfo</code> <p>The pagination metadata</p> required Source code in <code>sqlalchemy_bind_manager/_repository/common.py</code> <pre><code>class CursorPaginatedResult(BaseModel, Generic[MODEL]):\n    \"\"\"\n    The result of a cursor paginated query.\n\n    :param items: The models returned by the query\n    :type items: List[MODEL]\n    :param page_info: The pagination metadata\n    :type page_info: CursorPageInfo\n    \"\"\"\n\n    items: List[MODEL]\n    page_info: CursorPageInfo\n</code></pre>"},{"location":"api_reference/repository/#sqlalchemy_bind_manager.repository.CursorPageInfo","title":"sqlalchemy_bind_manager.repository.CursorPageInfo","text":"<p>Cursor-paginated query metadata.</p> <p>Parameters:</p> Name Type Description Default <code>items_per_page</code> <code>int</code> <p>The maximum number of items in a page.</p> required <code>total_items</code> <code>int</code> <p>The total items in all the pages.</p> required <code>has_next_page</code> <code>bool</code> <p>True if there is a next page.</p> required <code>has_previous_page</code> <code>bool</code> <p>True if there is a previous page.</p> required <code>start_cursor</code> <code>Union[CursorReference, None]</code> <p>The cursor pointing to the first item in the page, if at least one item is returned.</p> required <code>end_cursor</code> <code>Union[CursorReference, None]</code> <p>The cursor pointing to the last item in the page, if at least one item is returned.</p> required Source code in <code>sqlalchemy_bind_manager/_repository/common.py</code> <pre><code>class CursorPageInfo(BaseModel):\n    \"\"\"\n    Cursor-paginated query metadata.\n\n    :param items_per_page: The maximum number of items in a page.\n    :type items_per_page: int\n    :param total_items: The total items in all the pages.\n    :type total_items: int\n    :param has_next_page: True if there is a next page.\n    :type has_next_page: bool\n    :param has_previous_page: True if there is a previous page.\n    :type has_previous_page: bool\n    :param start_cursor: The cursor pointing to the first item in the page,\n    if at least one item is returned.\n    :type start_cursor: Union[CursorReference, None]\n    :param end_cursor: The cursor pointing to the last item in the page,\n    if at least one item is returned.\n    :type end_cursor: Union[CursorReference, None]\n    \"\"\"\n\n    items_per_page: int\n    total_items: int\n    has_next_page: bool = False\n    has_previous_page: bool = False\n    start_cursor: Union[CursorReference, None] = None\n    end_cursor: Union[CursorReference, None] = None\n</code></pre>"},{"location":"manager/alembic/","title":"Alembic integration","text":""},{"location":"manager/alembic/#using-alembic-with-sqlalchemy-bind-manager","title":"Using Alembic with SQLAlchemy bind manager","text":"<p>Alembic is a database migration tool widely used with SQLAlchemy.</p> <p>While the installation and configuration of Alembic is not in the scope of this package, <code>SQLAlchemyBindManager</code> class provides the method <code>get_bind_mappers_metadata()</code> for an easier integration with Alembic when using multiple binds. It will return each bind metadata organised in a dictionary, using the bind names as keys.</p> <p>Alembic provides templates for synchronous engines and for asynchronous engines, but there is no template supporting both at the same time.</p> <p>You can find an example Alembic configuration that works with synchronous and asynchronous engines at the same time, using the <code>SQLAlchemyBindManager</code> helper method, based on the following directory structure:</p> <pre><code>\u251c\u2500\u2500 alembic\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u2514\u2500\u2500 alembic.ini\n</code></pre>"},{"location":"manager/alembic/#alembicini","title":"alembic.ini","text":"alembic.ini <pre><code># a multi-database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file\n# for all available tokens\nfile_template = %%(year)d-%%(month).2d-%%(day).2d-%%(hour).2d%%(minute).2d%%(second).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to alembic/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"version_path_separator\" below.\n# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses os.pathsep.\n# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os  # Use os.pathsep. Default configuration used for new projects.\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# We inject db names and config using env.py in alembic directory\n#databases = engine1, engine2\n\n#[engine1]\n#sqlalchemy.url = driver://user:pass@localhost/dbname\n\n#[engine2]\n#sqlalchemy.url = driver://user:pass@localhost/dbname2\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n</code></pre>"},{"location":"manager/alembic/#envpy","title":"env.py","text":"env.py <pre><code>import logging\nimport os\nfrom asyncio import get_event_loop\n\nfrom alembic import context\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.asyncio import AsyncEngine\n\nfrom sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\n################################################################\n## Note: The bind_config, sa_manager and models are normally  ##\n## implemented in an application. This is only an example!    ##\n################################################################\nbind_config = {\n    \"default\": SQLAlchemyConfig(\n        engine_url=f\"sqlite+aiosqlite:///{os.path.dirname(os.path.abspath(__file__))}/sqlite.db\",\n        engine_options=dict(\n            connect_args={\n                \"check_same_thread\": False,\n            },\n            echo=False,\n            future=True,\n        ),\n        async_engine=True,\n    ),\n}\n\nsa_manager = SQLAlchemyBindManager(config=bind_config)\n\nclass BookModel(sa_manager.get_bind().declarative_base):\n    id = Column(Integer)\n    title = Column(String)\n################################################################\n## Note: The bind_config, sa_manager and models are normally  ##\n## implemented in an application. This is only an example!    ##\n################################################################\n\n\nUSE_TWOPHASE = False\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nlogger = logging.getLogger(\"alembic.env\")\ntarget_metadata = sa_manager.get_bind_mappers_metadata()\ndb_names = target_metadata.keys()\nconfig.set_main_option(\"databases\", \",\".join(db_names))\n\n\ndef run_migrations_offline() -&gt; None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    # for the --sql use case, run migrations for each URL into\n    # individual files.\n\n    engines = {}\n    for name in db_names:\n        engines[name] = {}\n        engines[name][\"url\"] = sa_manager.get_bind(name).engine.url\n\n    for name, rec in engines.items():\n        logger.info(f\"Migrating database {name}\")\n        file_ = f\"{name}.sql\"\n        logger.info(f\"Writing output to {file_}\")\n        with open(file_, \"w\") as buffer:\n            context.configure(\n                url=rec[\"url\"],\n                output_buffer=buffer,\n                target_metadata=target_metadata.get(name),\n                literal_binds=True,\n                dialect_opts={\"paramstyle\": \"named\"},\n            )\n            with context.begin_transaction():\n                context.run_migrations(engine_name=name)\n\n\ndef do_run_migration(conn, name):\n    context.configure(\n        connection=conn,\n        upgrade_token=f\"{name}_upgrades\",\n        downgrade_token=f\"{name}_downgrades\",\n        target_metadata=target_metadata.get(name),\n    )\n    context.run_migrations(engine_name=name)\n\n\nasync def run_migrations_online() -&gt; None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n\n    # for the direct-to-DB use case, start a transaction on all\n    # engines, then run all migrations, then commit all transactions.\n\n    engines = {}\n    for name in db_names:\n        engines[name] = {}\n        engines[name][\"engine\"] = sa_manager.get_bind(name).engine\n\n    for name, rec in engines.items():\n        engine = rec[\"engine\"]\n        if isinstance(engine, AsyncEngine):\n            rec[\"connection\"] = conn = await engine.connect()\n\n            if USE_TWOPHASE:\n                rec[\"transaction\"] = await conn.begin_twophase()\n            else:\n                rec[\"transaction\"] = await conn.begin()\n        else:\n            rec[\"connection\"] = conn = engine.connect()\n\n            if USE_TWOPHASE:\n                rec[\"transaction\"] = conn.begin_twophase()\n            else:\n                rec[\"transaction\"] = conn.begin()\n\n    try:\n        for name, rec in engines.items():\n            logger.info(f\"Migrating database {name}\")\n            if isinstance(rec[\"engine\"], AsyncEngine):\n\n                def migration_callable(*args, **kwargs):\n                    return do_run_migration(*args, name=name, **kwargs)\n\n                await rec[\"connection\"].run_sync(migration_callable)\n            else:\n                do_run_migration(name, rec)\n\n        if USE_TWOPHASE:\n            for rec in engines.values():\n                if isinstance(rec[\"engine\"], AsyncEngine):\n                    await rec[\"transaction\"].prepare()\n                else:\n                    rec[\"transaction\"].prepare()\n\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"transaction\"].commit()\n            else:\n                rec[\"transaction\"].commit()\n    except:\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"transaction\"].rollback()\n            else:\n                rec[\"transaction\"].rollback()\n        raise\n    finally:\n        for rec in engines.values():\n            if isinstance(rec[\"engine\"], AsyncEngine):\n                await rec[\"connection\"].close()\n            else:\n                rec[\"connection\"].close()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    loop = get_event_loop()\n    if loop.is_running():\n        loop.create_task(run_migrations_online())\n    else:\n        loop.run_until_complete(run_migrations_online())\n</code></pre>"},{"location":"manager/alembic/#scriptpymako","title":"script.py.mako","text":"script.py.mako <pre><code>&lt;%!\nimport re\n\n%&gt;\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n${imports if imports else \"\"}\n\n# revision identifiers, used by Alembic.\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade(engine_name: str) -&gt; None:\n    globals()[f\"upgrade_{engine_name}\"]()\n\n\ndef downgrade(engine_name: str) -&gt; None:\n    globals()[f\"downgrade_{engine_name}\"]()\n\n&lt;%\n    db_names = config.get_main_option(\"databases\")\n%&gt;\n\n## generate an \"upgrade_&lt;xyz&gt;() / downgrade_&lt;xyz&gt;()\" function\n## for each database name in the ini file.\n\n% for db_name in re.split(r',\\s*', db_names):\n\ndef upgrade_${db_name}() -&gt; None:\n    ${context.get(f\"{db_name}_upgrades\", \"pass\")}\n\n\ndef downgrade_${db_name}() -&gt; None:\n    ${context.get(f\"{db_name}_downgrades\", \"pass\")}\n\n% endfor\n</code></pre>"},{"location":"manager/config/","title":"Configuration","text":""},{"location":"manager/config/#single-database-configuration","title":"Single database configuration","text":"<p>You can initialise the manager providing an instance of <code>SQLAlchemyConfig</code></p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = SQLAlchemyConfig(\n    engine_url=\"sqlite:///./sqlite.db\",\n    engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n    session_options=dict(expire_on_commit=False),\n)\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>The <code>engine_url</code> and <code>engine_options</code> dictionaries accept the same parameters as SQLAlchemy create_engine()</p> <p>The <code>session_options</code> dictionary accepts the same parameters as SQLALchemy sessionmaker()</p> <p>Once the bind manager is initialised we can retrieve and use the SQLAlchemyBind using the method <code>get_bind()</code></p> <p>The <code>SQLAlchemyBind</code> class has the following attributes:</p> <ul> <li><code>engine</code>: The initialised SQLALchemy <code>Engine</code></li> <li><code>declarative_base</code>: A base class that can be used to create declarative models</li> <li><code>registry_mapper</code>: The <code>registry</code> associated with the <code>engine</code>. It can be used with Alembic or to setup imperative mapping</li> <li><code>session_class</code>: The class built by sessionmaker(), either <code>Session</code> or <code>AsyncSession</code></li> </ul> <p>The <code>SQLAlchemyBindManager</code> provides some helper methods to quickly access some of the bind properties without using the <code>SQLAlchemyBind</code>:</p> <ul> <li><code>get_session</code>: returns a Session object</li> <li><code>get_mapper</code>: returns the mapper associated with the bind</li> </ul>"},{"location":"manager/config/#multiple-databases-configuration","title":"Multiple databases configuration","text":"<p><code>SQLAlchemyBindManager</code> accepts also multiple databases configuration, provided as a dictionary. The dictionary keys are used as a reference name for each bind.</p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = {\n    \"default\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./sqlite.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n    \"secondary\": SQLAlchemyConfig(\n        engine_url=\"sqlite:///./secondary.db\",\n        engine_options=dict(connect_args={\"check_same_thread\": False}, echo=True),\n        session_options=dict(expire_on_commit=False),\n    ),\n}\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>All the <code>SQLAlchemyBindManager</code> helper methods accept the <code>bind_name</code> optional parameter:</p> <ul> <li><code>get_session(bind_name=\"default\")</code></li> <li><code>get_mapper(bind_name=\"default\")</code></li> </ul>"},{"location":"manager/config/#asynchronous-database-engines","title":"Asynchronous database engines","text":"<p>Is it possible to supply configurations for asyncio supported engines using the <code>async_engine</code> config property.</p> <pre><code>from sqlalchemy_bind_manager import SQLAlchemyConfig, SQLAlchemyBindManager\n\nconfig = SQLAlchemyConfig(\n    engine_url=\"postgresql+asyncpg://scott:tiger@localhost/test\",\n    async_engine=True,\n)\n\nsa_manager = SQLAlchemyBindManager(config)\n</code></pre> <p>This will make sure we initialise a <code>SQLAlchemyAsyncBind</code> object, containing <code>AsyncEngine</code> and <code>AsyncSession</code>.</p> <p>The interfaces are exactly the same, however you'll need to <code>await</code> the relevant functions in SQLAlchemy. E.g.:</p> <pre><code>async with sa_manager.get_session() as session:\n    session.add(o)\n    await session.commit()\n</code></pre> <p>Note that async implementation has several differences from the sync one, make sure to check SQLAlchemy asyncio documentation</p>"},{"location":"manager/models/","title":"Models setup","text":""},{"location":"manager/models/#models-configuration","title":"Models configuration","text":"<p>Creating models is exactly the same as SQLAlchemy documentation. </p> <p>Using declarative approach:</p> <pre><code>from sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy import String\n\nbind = sa_manager.get_bind()\n\nclass MyModel(bind.declarative_base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n</code></pre> <p>Or using the imperative approach:</p> <pre><code>from dataclasses import dataclass\nfrom sqlalchemy import Integer, String, Table, Column\n\n@dataclass\nclass MyModel:\n    id: int\n    name: str\n\nbind = sa_manager.get_bind()\n\nimperative_table = Table(\n    \"imperative\",\n    bind.registry_mapper.metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String, primary_key=True),\n)\n\nbind.registry_mapper.map_imperatively(MyModel, imperative_table)\n\n# or using the get_mapper() helper method\nsa_manager.get_mapper().map_imperatively(MyModel, imperative_table)\n</code></pre>"},{"location":"manager/session/","title":"Session usage","text":"<p>Using the session is the same as standard SQLAlchemy. The recommended approach is using the <code>get_session()</code> context manager, so you don't need to manage the session life cycle.</p> <pre><code># Persist an object\no = ImperativeModel()\no.name = \"John\"\nwith sa_manager.get_session() as session:\n    session.add(o)\n    session.commit()\n\n# We can also get the `session_class` property of the bind,\n# but this is not recommended.\nwith sa_manager.get_bind().session_class()() as session:\n    session.add(o)\n    session.commit()\n</code></pre>"},{"location":"manager/session/#note-on-multithreaded-applications","title":"Note on multithreaded applications","text":"<p>Global variables are shared between different threads in python. If your application uses multiple threads, like spawning a thread per request, then you should not store an initialised session in a global variable, otherwise the state of your models will be shared among the threads and produce undesired changes in the database.</p> <p>This is not thread safe:</p> <p>db.py (a module to have an easy to use session)</p> <pre><code>sa_manager = SQLAlchemyBindManager(some_config)\n\nsession = sa_manager.get_session()\n</code></pre> <p>some_other_module.py</p> <pre><code>from db import session\n\nsession.add(model)\nsession.commit()\n</code></pre> <p>This instead would be thread safe:</p> <p>db.py (a module to have an easy to use SQLAlchemyBindManager)</p> <pre><code>sa_manager = SQLAlchemyBindManager(some_config)\n</code></pre> <p>some_other_module.py</p> <pre><code>from db import sa_manager\n\ndef do_something():\n    session = sa_manager.get_session()\n    session.add(model)\n    session.commit()\n    session.close()\n\ndo_something()\n</code></pre> <p>As long as the <code>session</code> variable has no global scope it will be safe.</p> <p>Using the <code>get_session()</code> context manager is much easier</p> <p>If you truly need to have a long-lived session in a variable with global scope, you'll need to use a scoped session like this:</p> <pre><code>from sqlalchemy.orm import scoped_session\n\nsession = scoped_session(sa_manager.get_bind().session_class())\n</code></pre> <p>Handling the life cycle of scoped sessions is not supported by this documentations. Please refer to SQLAlchemy documentation about this.</p> <p>The repository implementation will handle the session life cycle for you</p>"},{"location":"repository/uow/","title":"Unit of work","text":""},{"location":"repository/uow/#use-the-unit-of-work-to-share-a-session-among-multiple-repositories","title":"Use the Unit Of Work to share a session among multiple repositories","text":"<p>It is possible we need to run several operations in a single database get_session. While a single repository provide by itself an isolated session for single operations, we have to use a different approach for multiple operations.</p> <p>We can use the <code>UnitOfWork</code> or the <code>AsyncUnitOfWork</code> class to provide a shared session to be used for repository operations.</p> <pre><code>class MyRepo(SQLAlchemyRepository):\n    _model = MyModel\n\nbind = sa_manager.get_bind()\nuow = UnitOfWork(bind)\nuow.register_repository(\"repo_a\", MyRepo)\n# args and kwargs are forwarded so we can also use directly `SQLAlchemyRepository` class\nuow.register_repository(\"repo_b\", SQLAlchemyRepository, MyOtherModel)\n\nwith uow.transaction():\n    uow.repository(\"repo_a\").save(some_model)\n    uow.repository(\"repo_b\").save(some_other_model)\n\n# Optionally disable the commit/rollback handling\nwith uow.transaction(read_only=True):\n    model1 = uow.repository(\"repo_a\").get(1)\n    model2 = uow.repository(\"repo_b\").get(2)\n</code></pre> <p>The unit of work implementation is limited to repositories using the same bind.</p> <p>Two-phase commits are not yet supported.</p> <p>Both the UnitOfWork classes create an internal <code>scoped_session</code> or <code>async_scoped_session</code>, behaving in the same way at the repositories do. This provides the freedom to tune the session lifecycle based on our application requirements (e.g. one unit of work per http request, per domain, etc.)</p>"},{"location":"repository/usage/","title":"Repository usage","text":""},{"location":"repository/usage/#repository-unit-of-work","title":"Repository / Unit of work","text":"<p>The <code>SQLAlchemyRepository</code> and <code>SQLAlchemyAsyncRepository</code> class can be used directly or by extending them.</p> <pre><code>from sqlalchemy_bind_manager.repository import SQLAlchemyRepository\n\n\nclass MyModel(declarative_base):\n    pass\n\n# Direct usage\nrepo_instance = SQLAlchemyRepository(\n    sa_manager.get_bind(),\n    model_class=MyModel\n)\n\n# Child class usage (when you need to implement custom repository methods)\nclass ModelRepository(SQLAlchemyRepository[MyModel]):\n    _model = MyModel\n\n    def _some_custom_method_implemented(self):\n        ...\n\nrepo_instance_2 = ModelRepository(sa_manager.get_bind())\n</code></pre> <p>The classes provide some common use methods:</p> <ul> <li><code>get</code>: Retrieve a model by identifier</li> <li><code>save</code>: Persist a model</li> <li><code>save_many</code>: Persist multiple models in a single transaction</li> <li><code>delete</code>: Delete a model</li> <li><code>find</code>: Search for a list of models (basically an adapter for SELECT queries)</li> <li><code>paginated_find</code>: Search for a list of models, with pagination support</li> <li><code>cursor_paginated_find</code>: Search for a list of models, with cursor based pagination support</li> </ul> Typing and Interfaces <p>The repository classes are fully typed (as the rest of this package). The repositories implement interface classes that are available to allow better code decoupling and inversion of control patterns such as dependency injection.</p> <pre><code>from sqlalchemy_bind_manager.repository import SQLAlchemyRepositoryInterface, SQLAlchemyAsyncRepositoryInterface\n\n\ndef some_function(repository: SQLAlchemyRepositoryInterface[MyModel]):\n    model = repository.get(123)\n    ...\n\n\nasync def some_async_function(repository: SQLAlchemyAsyncRepositoryInterface[MyModel]):\n    model = await repository.get(123)\n    ...\n</code></pre> <p>Both repository and related interface are Protocols, accepting the model class as a typing argument. You can also extend the protocols with your custom methods.</p> <pre><code>from typing import Protocol\nfrom sqlalchemy_bind_manager.repository import SQLAlchemyRepositoryInterface, SQLAlchemyRepository\n\n# SQLAlchemy model\nclass MyModel:\n    ...\n\nclass MyCustomRepositoryInterface(SQLAlchemyRepositoryInterface[MyModel], Protocol):\n    def some_custom_method(self, model: MyModel) -&gt; MyModel:\n        ...\n\nclass MyCustomRepository(SQLAlchemyRepository[MyModel]):\n    def some_custom_method(self, model: MyModel) -&gt; MyModel:\n        return model\n</code></pre>"},{"location":"repository/usage/#maximum-query-limit","title":"Maximum query limit","text":"<p>Repositories have a maximum limit for paginated queries defaulting to 50 to avoid pulling pages with too many items by mistake. You can override this limit by overriding the <code>_max_query_limit</code> repository property. E.g.:</p> <pre><code>class ModelRepository(SQLAlchemyRepository[MyModel]):\n    _model = MyModel\n    _max_query_limit: int = 2000\n</code></pre> <p>The query limit does not apply to the non paginated <code>find()</code></p>"},{"location":"repository/usage/#session-lifecycle-in-repositories","title":"Session lifecycle in repositories","text":"<p>SQLAlchemy documentation recommends we create <code>Session</code> object at the beginning of a logical operation where database access is potentially anticipated.</p> <p>Doing this too soon might cause unexpected effects, like unexpected updates being committed, if the initialised session is shared among different repositories.</p> <p>A <code>Repository</code> represents a generic interface to persist data object to a storage, not necessarily using SQLAlchemy. It makes sense that the lifecycle of a <code>Session</code> follows the one of the Repository (The assumption is: if we create a Repository, we're going to do a DB operation, otherwise we wouldn't need one).</p> <p>Each Repository instance create an internal scoped session. The session gets automatically closed when the Repository instance is not referenced by any variable (and the garbage collector cleans it up)</p> <p>In this way we ensure the <code>Session</code> we use is isolated, and the same for all the operations we do with the same Repository. </p> <p>This approach has a consequence: We can't use SQLAlchemy lazy loading, so we'll need to make sure relationship are always loaded eagerly, using either approach: * Setup your model/table relationships to always use always eager loading * Implement ad-hoc methods to deal with relationships as necessary</p> <p>Note that <code>AsyncSession</code> has the same limitation on lazy loading, even when keeping the session opened, so it makes sense that the two Repository implementations behave consistently.</p> Lazy loading using <code>AsyncAttrs</code> <p>SQLAlchemy has recently added the <code>AsyncAttrs</code> model class mixin to allow lazy loading model attributes  with <code>AsyncSession</code>, however having to <code>await</code> a model property introduce a coupling between the application logic and the storage layer.</p> <p>This would mean the application logic has to know about the storage layer and make a distinction between sync and async models. This doesn't feel right, at least for now, therefore it's not enabled by default.</p> <p>If you want to attempt lazy loading refer to SQLAlchemy documentation</p>"}]}